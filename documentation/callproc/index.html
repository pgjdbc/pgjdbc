<!doctype html><html><head><meta charset=utf-8><link rel=preload href=https://pgjdbc.github.io/pgjdbc/fonts/woff2/inria-sans-v14-latin-300.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=https://pgjdbc.github.io/pgjdbc/fonts/woff2/inria-sans-v14-latin-300italic.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=https://pgjdbc.github.io/pgjdbc/fonts/woff2/inria-sans-v14-latin-regular.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=https://pgjdbc.github.io/pgjdbc/fonts/woff2/inria-sans-v14-latin-700.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=https://pgjdbc.github.io/pgjdbc/fonts/woff2/inria-sans-v14-latin-italic.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=https://pgjdbc.github.io/pgjdbc/fonts/woff2/inria-sans-v14-latin-700italic.woff2 as=font type=font/woff2 crossorigin><title>Calling Stored Functions and Procedures | Pgjdbc</title><meta name=viewport content="width=device-width,minimum-scale=1"><link rel=stylesheet href=https://pgjdbc.github.io/pgjdbc/sass/main.ad8d39bcb73da9b9260850a40900e7af4477352c415da494ee27745e8ef7dc8f.css integrity="sha256-rY05vLc9qbkmCFCkCQDnr0R3NSxBXaSU7id0Xo733I8="><link rel=icon href=/pgjdbc/favicon.ico></head><body><nav class=navbar role=navigation><a href=/pgjdbc><img src=/pgjdbc/icons/postgreslogo.svg class=logo></a><div class=navbar__items><a href=/pgjdbc/download/ class=navbar__items__link>Download</a>
<a href=/pgjdbc/documentation/ class=navbar__items__link>Documentation</a>
<a href=/pgjdbc/community/ class=navbar__items__link>Community</a>
<a href=/pgjdbc/development/ class=navbar__items__link>Development</a></div><a href=https://github.com/pgjdbc/pgjdbc target=_blank><img src=/pgjdbc/icons/github.svg class=github></a></nav><main role=main><div class=doc><nav role=navigation class=sidebar><ul role=list class=flow><li role=listitem><a href=/pgjdbc/documentation/setup/>Getting Started</a></li><li role=listitem><a href=/pgjdbc/documentation/use/>Initializing the Driver</a></li><li role=listitem><a href=/pgjdbc/documentation/ssl/>Using SSL</a></li><li role=listitem><a href=/pgjdbc/documentation/query/>Issuing a Query and Processing the Result</a></li><li role=listitem><a href=/pgjdbc/documentation/callproc/>Calling Stored Functions and Procedures</a></li><li role=listitem><a href=/pgjdbc/documentation/binary-data/>Storing Binary Data</a></li><li role=listitem><a href=/pgjdbc/documentation/escapes/>JDBC escapes</a></li><li role=listitem><a href=/pgjdbc/documentation/server-prepare/>PostgreSQL™ Extensions to the JDBC API</a></li><li role=listitem><a href=/pgjdbc/documentation/thread/>Using the Driver in a Multithreaded or a Servlet Environment</a></li><li role=listitem><a href=/pgjdbc/documentation/datasource/>Connection Pools and Data Sources</a></li><li role=listitem><a href=/pgjdbc/documentation/logging/>Logging using java.util.logging</a></li><li role=listitem><a href=/pgjdbc/documentation/reading/>Further Reading</a></li></ul></nav><article class="article flow"><h1 id=calling-stored-functions-and-procedures>Calling Stored Functions and Procedures</h1><p>PostgreSQL™ supports two types of stored objects, functions that can return a
result value and - starting from v11 - procedures that can perform transaction
control. Both types of stored objects are invoked using <code>CallableStatement</code> and
the standard JDBC escape call syntax <code>{call storedobject(?)}</code> . The
<code>escapeSyntaxCallMode</code> connection property controls how the driver transforms the
call syntax to invoke functions or procedures.</p><p>The default mode, <code>select</code> , supports backwards compatibility for existing
applications and supports function invocation only. This is required to invoke
a void returning function. For new applications, use
<code>escapeSyntaxCallMode=callIfNoReturn</code> to map <code>CallableStatement</code> s with return
values to stored functions and <code>CallableStatement</code> s without return values to
stored procedures.</p><p><strong>Example 6.1. Calling a built in stored function</strong></p><p>This example shows how to call a PostgreSQL™ built in function, <code>upper</code> , which
simply converts the supplied string argument to uppercase.</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>CallableStatement</span> <span class=n>upperFunc</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=na>prepareCall</span><span class=o>(</span><span class=s>&#34;{? = call upper( ? ) }&#34;</span><span class=o>);</span>
<span class=n>upperFunc</span><span class=o>.</span><span class=na>registerOutParameter</span><span class=o>(</span><span class=n>1</span><span class=o>,</span> <span class=n>Types</span><span class=o>.</span><span class=na>VARCHAR</span><span class=o>);</span>
<span class=n>upperFunc</span><span class=o>.</span><span class=na>setString</span><span class=o>(</span><span class=n>2</span><span class=o>,</span> <span class=s>&#34;lowercase to uppercase&#34;</span><span class=o>);</span>
<span class=n>upperFunc</span><span class=o>.</span><span class=na>execute</span><span class=o>();</span>
<span class=n>String</span> <span class=n>upperCased</span> <span class=o>=</span> <span class=n>upperFunc</span><span class=o>.</span><span class=na>getString</span><span class=o>(</span><span class=n>1</span><span class=o>);</span>
<span class=n>upperFunc</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>
</code></pre></div><h2 id=obtaining-a-resultset-from-a-stored-function>Obtaining a <code>ResultSet</code> from a stored function <a class=header-link href=#obtaining-a-resultset-from-a-stored-function><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>PostgreSQL&rsquo;s™ stored functions can return results in two different ways. The
function may return either a refcursor value or a <code>SETOF</code> some datatype. Depending
on which of these return methods are used determines how the function should be
called.</p><h3 id=from-a-function-returning-setof-type>From a Function Returning <code>SETOF</code> type <a class=header-link href=#from-a-function-returning-setof-type><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h3><p>Functions that return data as a set should not be called via the <code>CallableStatement</code></p><p>interface, but instead should use the normal <code>Statement</code> or <code>PreparedStatement</code></p><p>interfaces.</p><p><strong>Example 6.2. Getting <code>SETOF</code> type values from a function</strong></p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Statement</span> <span class=n>stmt</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=na>createStatement</span><span class=o>();</span>
<span class=n>stmt</span><span class=o>.</span><span class=na>execute</span><span class=o>(</span><span class=s>&#34;CREATE OR REPLACE FUNCTION setoffunc() RETURNS SETOF int AS &#34;</span>
    <span class=o>+</span> <span class=s>&#34;&#39; SELECT 1 UNION SELECT 2;&#39; LANGUAGE sql&#34;</span><span class=o>);</span>
<span class=n>ResultSet</span> <span class=n>rs</span> <span class=o>=</span> <span class=n>stmt</span><span class=o>.</span><span class=na>executeQuery</span><span class=o>(</span><span class=s>&#34;SELECT * FROM setoffunc()&#34;</span><span class=o>);</span>
<span class=k>while</span> <span class=o>(</span><span class=n>rs</span><span class=o>.</span><span class=na>next</span><span class=o>())</span>
<span class=o>{</span>
    <span class=c1>// do something
</span><span class=c1></span><span class=o>}</span>
<span class=n>rs</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>
<span class=n>stmt</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>
</code></pre></div><h2 id=from-a-function-returning-a-refcursor>From a Function Returning a refcursor <a class=header-link href=#from-a-function-returning-a-refcursor><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>When calling a function that returns a refcursor you must cast the return type of
<code>getObject</code> to a <code>ResultSet</code></p><div class="admonition admonition--note"><div class=admonition__heading><h4><span class=admonition__icon><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942.0 01-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28s.52.09.7.28c.18.19.28.42.28.7s-.09.52-.28.7a1 1 0 01-.7.3c-.28.0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27.0.48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14.0-5.7 2.54-5.7 5.68s2.56 5.7 5.7 5.7 5.7-2.55 5.7-5.7-2.56-5.69-5.7-5.69v.01zM7 .98c3.86.0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"/></svg></span>NOTE</h4></div><div class=admonition__content><p>One notable limitation of the current support for a <code>ResultSet</code> created from
a refcursor is that even though it is a cursor backed <code>ResultSet</code> , all data will
be retrieved and cached on the client. The <code>Statement</code> fetch size parameter
described in the section called <a href=query.html#query-with-cursor>“Getting results based on a cursor”</a>
is ignored. This limitation is a deficiency of the JDBC driver, not the server,
and it is technically possible to remove it, we just haven&rsquo;t found the time.</p></div></div><p><strong>Example 6.3. Getting refcursor Value From a Function</strong></p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// Setup function to call.
</span><span class=c1></span><span class=n>Statement</span> <span class=n>stmt</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=na>createStatement</span><span class=o>();</span>
<span class=n>stmt</span><span class=o>.</span><span class=na>execute</span><span class=o>(</span><span class=s>&#34;CREATE OR REPLACE FUNCTION refcursorfunc() RETURNS refcursor AS &#39;&#34;</span>
    <span class=o>+</span> <span class=s>&#34; DECLARE &#34;</span>
    <span class=o>+</span> <span class=s>&#34;    mycurs refcursor; &#34;</span>
    <span class=o>+</span> <span class=s>&#34; BEGIN &#34;</span>
    <span class=o>+</span> <span class=s>&#34;    OPEN mycurs FOR SELECT 1 UNION SELECT 2; &#34;</span>
    <span class=o>+</span> <span class=s>&#34;    RETURN mycurs; &#34;</span>
    <span class=o>+</span> <span class=s>&#34; END;&#39; language plpgsql&#34;</span><span class=o>);</span>
<span class=n>stmt</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>

<span class=c1>// We must be inside a transaction for cursors to work.
</span><span class=c1></span><span class=n>conn</span><span class=o>.</span><span class=na>setAutoCommit</span><span class=o>(</span><span class=kc>false</span><span class=o>);</span>

<span class=c1>// Function call.
</span><span class=c1></span><span class=n>CallableStatement</span> <span class=n>func</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=na>prepareCall</span><span class=o>(</span><span class=s>&#34;{? = call refcursorfunc() }&#34;</span><span class=o>);</span>
<span class=n>func</span><span class=o>.</span><span class=na>registerOutParameter</span><span class=o>(</span><span class=n>1</span><span class=o>,</span> <span class=n>Types</span><span class=o>.</span><span class=na>OTHER</span><span class=o>);</span>
<span class=n>func</span><span class=o>.</span><span class=na>execute</span><span class=o>();</span>
<span class=n>ResultSet</span> <span class=n>results</span> <span class=o>=</span> <span class=o>(</span><span class=n>ResultSet</span><span class=o>)</span> <span class=n>func</span><span class=o>.</span><span class=na>getObject</span><span class=o>(</span><span class=n>1</span><span class=o>);</span>
<span class=k>while</span> <span class=o>(</span><span class=n>results</span><span class=o>.</span><span class=na>next</span><span class=o>())</span>
<span class=o>{</span>
    <span class=c1>// do something with the results.
</span><span class=c1></span><span class=o>}</span>
<span class=n>results</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>
<span class=n>func</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>
</code></pre></div><p>It is also possible to treat the refcursor return value as a cursor name directly.
To do this, use the <code>getString</code> of <code>ResultSet</code> . With the underlying cursor name,
you are free to directly use cursor commands on it, such as <code>FETCH</code> and <code>MOVE</code> .</p><p><strong>Example 6.4. Treating refcursor as a cursor name</strong></p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>conn</span><span class=o>.</span><span class=na>setAutoCommit</span><span class=o>(</span><span class=kc>false</span><span class=o>);</span>
<span class=n>CallableStatement</span> <span class=n>func</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=na>prepareCall</span><span class=o>(</span><span class=s>&#34;{? = call refcursorfunc() }&#34;</span><span class=o>);</span>
<span class=n>func</span><span class=o>.</span><span class=na>registerOutParameter</span><span class=o>(</span><span class=n>1</span><span class=o>,</span> <span class=n>Types</span><span class=o>.</span><span class=na>OTHER</span><span class=o>);</span>
<span class=n>func</span><span class=o>.</span><span class=na>execute</span><span class=o>();</span>
<span class=n>String</span> <span class=n>cursorName</span> <span class=o>=</span> <span class=n>func</span><span class=o>.</span><span class=na>getString</span><span class=o>(</span><span class=n>1</span><span class=o>);</span>
<span class=n>func</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>
</code></pre></div><p>**Example 6.5. Calling a stored procedure</p><p>This example shows how to call a PostgreSQL™ procedure that uses transaction control.</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>// set up a connection
</span><span class=c1></span><span class=n>String</span> <span class=n>url</span> <span class=o>=</span> <span class=s>&#34;jdbc:postgresql://localhost/test&#34;</span><span class=o>;</span>
<span class=n>Properties</span> <span class=n>props</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Properties</span><span class=o>();</span>
<span class=o>...</span> <span class=n>other</span> <span class=n>properties</span> <span class=o>...</span>
<span class=c1>// Ensure EscapeSyntaxCallmode property set to support procedures if no return value
</span><span class=c1></span><span class=n>props</span><span class=o>.</span><span class=na>setProperty</span><span class=o>(</span><span class=s>&#34;escapeSyntaxCallMode&#34;</span><span class=o>,</span> <span class=s>&#34;callIfNoReturn&#34;</span><span class=o>);</span>
<span class=n>Connection</span> <span class=n>con</span> <span class=o>=</span> <span class=n>DriverManager</span><span class=o>.</span><span class=na>getConnection</span><span class=o>(</span><span class=n>url</span><span class=o>,</span> <span class=n>props</span><span class=o>);</span>

<span class=c1>// Setup procedure to call.
</span><span class=c1></span><span class=n>Statement</span> <span class=n>stmt</span> <span class=o>=</span> <span class=n>con</span><span class=o>.</span><span class=na>createStatement</span><span class=o>();</span>
<span class=n>stmt</span><span class=o>.</span><span class=na>execute</span><span class=o>(</span><span class=s>&#34;CREATE TEMP TABLE temp_val ( some_val bigint )&#34;</span><span class=o>);</span>
<span class=n>stmt</span><span class=o>.</span><span class=na>execute</span><span class=o>(</span><span class=s>&#34;CREATE OR REPLACE PROCEDURE commitproc(a INOUT bigint) AS &#39;&#34;</span>
    <span class=o>+</span> <span class=s>&#34; BEGIN &#34;</span>
    <span class=o>+</span> <span class=s>&#34;    INSERT INTO temp_val values(a); &#34;</span>
    <span class=o>+</span> <span class=s>&#34;    COMMIT; &#34;</span>
    <span class=o>+</span> <span class=s>&#34; END;&#39; LANGUAGE plpgsql&#34;</span><span class=o>);</span>
<span class=n>stmt</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>

<span class=c1>// As of v11, we must be outside a transaction for procedures with transactions to work.
</span><span class=c1></span><span class=n>con</span><span class=o>.</span><span class=na>setAutoCommit</span><span class=o>(</span><span class=kc>true</span><span class=o>);</span>

<span class=c1>// Procedure call with transaction
</span><span class=c1></span><span class=n>CallableStatement</span> <span class=n>proc</span> <span class=o>=</span> <span class=n>con</span><span class=o>.</span><span class=na>prepareCall</span><span class=o>(</span><span class=s>&#34;{call commitproc( ? )}&#34;</span><span class=o>);</span>
<span class=n>proc</span><span class=o>.</span><span class=na>setInt</span><span class=o>(</span><span class=n>1</span><span class=o>,</span> <span class=n>100</span><span class=o>);</span>
<span class=n>proc</span><span class=o>.</span><span class=na>execute</span><span class=o>();</span>
<span class=n>proc</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>
</code></pre></div><div class=pagination><p><a title="Next page in Issuing a Query and Processing the Result" href=https://pgjdbc.github.io/pgjdbc/documentation/query/>Issuing a Query and Processing the Result | 4</a></p><p><a title="Previous page in Storing Binary Data" href=https://pgjdbc.github.io/pgjdbc/documentation/binary-data/>Storing Binary Data | 6</a></p></div></article><aside class=toc><h4>Calling Stored Functions and Procedures</h4><nav id=TableOfContents><ul><li><a href=#obtaining-a-resultset-from-a-stored-function>Obtaining a <code>ResultSet</code> from a stored function</a><ul><li><a href=#from-a-function-returning-setof-type>From a Function Returning <code>SETOF</code> type</a></li></ul></li><li><a href=#from-a-function-returning-a-refcursor>From a Function Returning a refcursor</a></li></ul></nav></aside></div></main><footer class=footer role=contentinfo><div class=footer__items><div class=footer__items__links><ul role=list><li>Pgjdbc</li><li><a href=https://jdbc.postgresql.org/documentation/publicapi/index.html>Public API</a></li><li><a href=https://www.postgresql.org/>About PostgreSql</a></li></ul></div><div class=footer__items__links><ul role=list><li>Community</li><li><a href=https://jdbc.postgresql.org/documentation/publicapi/index.html>Slack</a></li><li><a href=https://www.postgresql.org/>Twitter</a></li><li><a href=https://www.postgresql.org/>Mailing List</a></li></ul></div><div class=footer__items__links><ul role=list><li>More</li><li><a href=https://jdbc.postgresql.org/documentation/publicapi/index.html>FAQ</a></li><li><a href=https://www.postgresql.org/>Privacy</a></li><li><a href=https://www.postgresql.org/>License</a></li></ul></div></div><p class=copyright>Copyright © 1996-2022 The PostgreSQL Global Development Group</p></footer></body></html>