<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PostgreSQL™ Extensions to the JDBC API on Pgjdbc</title><link>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/</link><description>Recent content in PostgreSQL™ Extensions to the JDBC API on Pgjdbc</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 19 Jun 2022 22:46:55 +0530</lastBuildDate><atom:link href="https://pgjdbc.github.io/pgjdbc/documentation/chapter9/index.xml" rel="self" type="application/rss+xml"/><item><title>PostgreSQL™ Extensions to the JDBC API</title><link>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/ext/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/ext/</guid><description>PostgreSQL™ is an extensible database system. You can add your own functions to the server, which can then be called from queries, or even add your own data types. As these are facilities unique to PostgreSQL™, we support them from Java, with a set of extension APIs. Some features within the core of the standard driver actually use these extensions to implement Large Objects, etc.
Accessing the Extensions To access some of the extensions, you need to use some extra methods in the org.</description></item><item><title>Geometric Data Types</title><link>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/geometric/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/geometric/</guid><description>PostgreSQL™ has a set of data types that can store geometric features into a table. These include single points, lines, and polygons. We support these types in Java with the org.postgresql.geometric package. Please consult the Javadoc mentioned in Chapter 13, Further Reading for details of available classes and features.
Example 9.1. Using the CIRCLE datatype JDBC
import java.sql.*; import org.postgresql.geometric.PGpoint; import org.postgresql.geometric.PGcircle; public class GeometricTest { public static void main(String args[]) throws Exception { String url = &amp;#34;jdbc:postgresql://localhost:5432/test&amp;#34;; try (Connection conn = DriverManager.</description></item><item><title>Large Objects</title><link>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/largeobjects/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/largeobjects/</guid><description>Large objects are supported in the standard JDBC specification. However, that interface is limited, and the API provided by PostgreSQL™ allows for random access to the objects contents, as if it was a local file.
The org.postgresql.largeobject package provides to Java the libpq C interface&amp;rsquo;s large object API. It consists of two classes, LargeObjectManager, which deals with creating, opening and deleting large objects, and LargeObject which deals with an individual object.</description></item><item><title>Listen / Notify</title><link>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/listennotify/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/listennotify/</guid><description>Listen and Notify provide a simple form of signal or interprocess communication mechanism for a collection of processes accessing the same PostgreSQL™ database. For more information on notifications consult the main server documentation. This section only deals with the JDBC specific aspects of notifications.
Standard LISTEN, NOTIFY, and UNLISTEN commands are issued via the standard Statement interface. To retrieve and process retrieved notifications the Connection must be cast to the PostgreSQL™ specific extension interface PGConnection.</description></item><item><title>Server Prepared Statements</title><link>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/server-prepare/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/server-prepare/</guid><description>Motivation The PostgreSQL™ server allows clients to compile sql statements that are expected to be reused to avoid the overhead of parsing and planning the statement for every execution. This functionality is available at the SQL level via PREPARE and EXECUTE beginning with server version 7.3, and at the protocol level beginning with server version 7.4, but as Java developers we really just want to use the standard PreparedStatement interface.</description></item><item><title>Parameter Status Messages</title><link>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/parameterstatus/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/parameterstatus/</guid><description>Parameter Status Messages PostgreSQL supports server parameters, also called server variables or, internally, Grand Unified Configuration (GUC) variables. These variables are manipulated by the SET command, postgresql.conf, ALTER SYSTEM SET, ALTER USER SET, ALTER DATABASE SET, the set_config(...) SQL-callable function, etc. See the PostgreSQL manual.
For a subset of these variables the server will automatically report changes to the value to the client driver and application. These variables are known internally as GUC_REPORT variables after the name of the flag that enables the functionality.</description></item><item><title>Physical and Logical replication API</title><link>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/replication/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/replication/</guid><description>Overview Postgres 9.4 (released in December 2014) introduced a new feature called logical replication. Logical replication allows changes from a database to be streamed in real-time to an external system. The difference between physical replication and logical replication is that logical replication sends data over in a logical format whereas physical replication sends data over in a binary format. Additionally logical replication can send over a single table, or database. Binary replication replicates the entire cluster in an all or nothing fashion; which is to say there is no way to get a specific table or database using binary replication</description></item><item><title>Arrays</title><link>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/arrays/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://pgjdbc.github.io/pgjdbc/documentation/chapter9/arrays/</guid><description>PostgreSQL™ provides robust support for array data types as column types, function arguments and criteria in where clauses. There are several ways to create arrays with pgjdbc.
The java.sql.Connection.createArrayOf(String, Object[]) can be used to create an java.sql.Array from Object[] instances (Note: this includes both primitive and object multi-dimensional arrays). A similar method org.postgresql.PGConnection.createArrayOf(String, Object) provides support for primitive array types. The java.sql.Array object returned from these methods can be used in other methods, such as PreparedStatement.</description></item></channel></rss>