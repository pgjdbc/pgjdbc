/* Automatically generated by GNU msgfmt.  Do not modify!  */
package org.postgresql.translation;
public class messages_ja extends java.util.ResourceBundle {
  private static final java.lang.String[] table;
  static {
    java.lang.String[] t = new java.lang.String[1178];
    t[0] = "";
    t[1] = "Project-Id-Version: head-ja\nReport-Msgid-Bugs-To: \nPO-Revision-Date: 2018-07-23 11:10+0900\nLast-Translator: Kyotaro Horiguchi <horiguchi.kyotaro@lab.ntt.co.jp>\nLanguage-Team: PostgreSQL <z-saito@guitar.ocn.ne.jp>\nLanguage: ja_JP\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\nX-Generator: Poedit 1.5.4\n";
    t[6] = "PostgreSQL LOBs can only index to: {0}";
    t[7] = "PostgreSQL LOB 上の位置指定は最大 {0} までです";
    t[14] = "The server does not support SSL.";
    t[15] = "サーバはSSLをサポートしていません。";
    t[22] = "Error disabling autocommit";
    t[23] = "自動コミットの無効化処理中のエラー";
    t[24] = "Hint: {0}";
    t[25] = "ヒント: {0}";
    t[28] = "Interrupted while attempting to connect.";
    t[29] = "接続試行中に割り込みがありました。";
    t[32] = "Can''t use query methods that take a query string on a PreparedStatement.";
    t[33] = "PreparedStatement でクエリ文字列を取るクエリメソッドは使えません。";
    t[34] = "Got CopyInResponse from server during an active {0}";
    t[35] = "{0} を実行中のサーバから CopyInResponse を受け取りました";
    t[38] = "Cannot rollback when autoCommit is enabled.";
    t[39] = "autoCommit有効時に、明示的なロールバックはできません。";
    t[40] = "tried to call end without corresponding start call. state={0}, start xid={1}, currentXid={2}, preparedXid={3}";
    t[41] = "対応する start の呼び出しなしで、end を呼び出しました。state={0}, start xid={1}, currentXid={2}, preparedXid={3}";
    t[46] = "DataSource has been closed.";
    t[47] = "データソースはクローズされました。";
    t[54] = "The fastpath function {0} is unknown.";
    t[55] = "{0} は未知の fastpath 関数です。";
    t[56] = "The driver currently does not support COPY operations.";
    t[57] = "ドライバはコピー操作をサポートしていません。";
    t[60] = "Illegal UTF-8 sequence: final value is out of range: {0}";
    t[61] = "不正なUTF-8シーケンス: 変換後の値が範囲外です: {0}";
    t[64] = "Prepare called before end. prepare xid={0}, state={1}";
    t[65] = "end より前に prepare が呼ばれました prepare xid={0}, state={1}";
    t[66] = "Internal Query: {0}";
    t[67] = "内部クエリ: {0}";
    t[68] = "An unexpected result was returned by a query.";
    t[69] = "クエリが想定外の結果を返却しました。";
    t[70] = "Cannot change transaction read-only property in the middle of a transaction.";
    t[71] = "トランザクションの中で read-only プロパティは変更できません。";
    t[72] = "Invalid server-final-message: {0}";
    t[73] = "不正な server-final-message: {0}.";
    t[82] = "Transaction isolation level {0} not supported.";
    t[83] = "トランザクション分離レベル{0} はサポートされていません。";
    t[88] = "Requested CopyIn but got {0}";
    t[89] = "CopyIn を要求しましたが {0} が返却されました";
    t[90] = "Tried to write to an inactive copy operation";
    t[91] = "実行中ではないコピー操作に書き込もうとしました";
    t[94] = "{0} function takes four and only four argument.";
    t[95] = "{0} 関数はちょうど4個の引数を取ります。";
    t[98] = "Unable to decode xml data.";
    t[99] = "xmlデータをデコードできません。";
    t[100] = "The server''s standard_conforming_strings parameter was reported as {0}. The JDBC driver expected on or off.";
    t[101] = "サーバのstandard_conforming_stringsパラメータは、{0}であると報告されました。JDBCドライバは、on または off を想定しています。";
    t[102] = "There are no rows in this ResultSet.";
    t[103] = "このResultSetに行がありません。";
    t[104] = "This replication stream has been closed.";
    t[105] = "このレプリケーション接続は既にクローズされています。";
    t[106] = "Server SQLState: {0}";
    t[107] = "サーバ SQLState: {0}";
    t[108] = "This copy stream is closed.";
    t[109] = "このコピーストリームはクローズされています。";
    t[112] = "Could not initialize SSL context.";
    t[113] = "SSLコンテクストを初期化できませんでした。";
    t[114] = "One-phase commit with unknown xid. commit xid={0}, currentXid={1}";
    t[115] = "未知の xid の単相コミット。 コミットxid={0}, 現在のxid={1}";
    t[120] = "The server''s DateStyle parameter was changed to {0}. The JDBC driver requires DateStyle to begin with ISO for correct operation.";
    t[121] = "サーバのDateStyleパラメータは、{0} に変わりました。JDBCドライバが正しく動作するためには、DateStyle が ISO で始まる値である必要があります。";
    t[122] = "Database connection failed when reading from copy";
    t[123] = "コピーからの読み取り中にデータベース接続で異常が発生しました";
    t[124] = "Provided InputStream failed.";
    t[125] = "渡された InputStream で異常が発生しました。";
    t[128] = "The system property containing the server's SSL certificate must not be empty.";
    t[129] = "サーバーのSSL証明書を指定するシステムプロパティは空であってはなりません。";
    t[142] = "One or more ClientInfo failed.";
    t[143] = "1つ以上の ClinentInfo で問題が発生しました。";
    t[144] = "ResultSet is not updateable.  The query that generated this result set must select only one table, and must select all primary keys from that table. See the JDBC 2.1 API Specification, section 5.6 for more details.";
    t[145] = "ResultSetは更新不可です。この結果セットを生成したクエリは、ただ一つのテーブルを選択して、そのテーブルの全ての主キーを選択する必要があります。詳細に関しては JDBC 2.1 API仕様、章 5.6 を参照して下さい。";
    t[148] = "The maximum field size must be a value greater than or equal to 0.";
    t[149] = "最大の項目サイズは、0またはより大きな値でなくてはなりません。";
    t[152] = "The array index is out of range: {0}";
    t[153] = "配列インデックスが範囲外です: {0}";
    t[154] = "Unexpected command status: {0}.";
    t[155] = "想定外のコマンドステータス: {0}。";
    t[156] = "Unknown XML Result class: {0}";
    t[157] = "未知のXML結果クラス: {0}";
    t[160] = "Unexpected copydata from server for {0}";
    t[161] = "{0} を実行中のサーバからのあり得ない CopyData";
    t[162] = "Premature end of input stream, expected {0} bytes, but only read {1}.";
    t[163] = "入力ストリームが途中で終了しました、{0} バイトを読み込もうとしましたが、 {1} バイトしかありませんでした。";
    t[166] = "xid must not be null";
    t[167] = "xidはnullではいけません。";
    t[168] = "Database connection failed when canceling copy operation";
    t[169] = "コピー操作中断のためのデータベース接続に失敗しました";
    t[174] = "No primary key found for table {0}.";
    t[175] = "テーブル {0} には主キーがありません。";
    t[180] = "Enter SSL password: ";
    t[181] = "SSLパスワード入力: ";
    t[182] = "{0} function takes one and only one argument.";
    t[183] = "{0} 関数はちょうど1個の引数を取ります。";
    t[184] = "Illegal UTF-8 sequence: initial byte is {0}: {1}";
    t[185] = "不正なUTF-8シーケンス: 先頭バイトが {0}: {1}";
    t[188] = "Unsupported properties: {0}";
    t[189] = "サポートされないプロパティ: {0}";
    t[192] = "Interrupted while waiting to obtain lock on database connection";
    t[193] = "データベース接続のロック待ちの最中に割り込みがありました";
    t[194] = "Could not find a java cryptographic algorithm: X.509 CertificateFactory not available.";
    t[195] = "javaの暗号化アルゴリズムを見つけることができませんでした。X.509 CertificateFactory は利用できません。";
    t[204] = "No value specified for parameter {0}.";
    t[205] = "パラメータ {0} に値が設定されてません。";
    t[210] = "Location: File: {0}, Routine: {1}, Line: {2}";
    t[211] = "場所: ファイル: {0}, ルーチン: {1},行: {2}";
    t[212] = "An error occurred while trying to reset the socket timeout.";
    t[213] = "ソケットタイムアウトのリセット中にエラーが発生しました。";
    t[216] = "Cannot update the ResultSet because it is either before the start or after the end of the results.";
    t[217] = "開始位置より前もしくは終了位置より後ろであるため、ResultSetを更新することができません。";
    t[218] = "SSL error: {0}";
    t[219] = "SSL エラー: {0}";
    t[220] = "{0} function doesn''t take any argument.";
    t[221] = "{0} 関数は引数を取りません。";
    t[222] = "Unsupported type conversion to {1}.";
    t[223] = "{1} への型変換はサポートされていません。";
    t[224] = "An error occurred reading the certificate";
    t[225] = "証明書の読み込み中にエラーが起きました";
    t[228] = "Transaction control methods setAutoCommit(true), commit, rollback and setSavePoint not allowed while an XA transaction is active.";
    t[229] = "トランザクション制御メソッド setAutoCommit(true), commit, rollback, setSavePoint は、XAトランザクションが有効である間は利用できません。";
    t[232] = "Validating connection.";
    t[233] = "コネクションを検証しています";
    t[234] = "Could not open SSL root certificate file {0}.";
    t[235] = "SSLルート証明書ファイル {0} をオープンできませんでした。";
    t[236] = "Received CommandComplete ''{0}'' without an active copy operation";
    t[237] = "実行中のコピー操作がないにもかかわらず CommandComplete ''{0}'' を受信しました";
    t[242] = "free() was called on this LOB previously";
    t[243] = "このLOBに対して free() はすでに呼び出し済みです";
    t[244] = "The hostname {0} could not be verified by hostnameverifier {1}.";
    t[245] = "ホスト名 {0} は、hostnameverifier {1} で検証できませんでした。";
    t[246] = "Heuristic commit/rollback not supported. forget xid={0}";
    t[247] = "ヒューリスティック commit/rollback はサポートされません。forget xid={0}";
    t[252] = "Got CopyOutResponse from server during an active {0}";
    t[253] = "{0} を実行中のサーバから CopyOutResponse を受け取りました";
    t[254] = "Current connection does not have an associated xid. prepare xid={0}";
    t[255] = "この接続は xid と関連付けられていません。プリペア xid={0}";
    t[258] = "Got {0} error responses to single copy cancel request";
    t[259] = "一つのコピー中断要求にたいして {0} 個のエラー応答が返されました";
    t[260] = "Read from copy failed.";
    t[261] = "コピーストリームからの読み取りに失敗しました。";
    t[264] = "Query timeout must be a value greater than or equals to 0.";
    t[265] = "クエリタイムアウトは、0またはより大きな値でなくてはなりません。";
    t[272] = "A result was returned when none was expected.";
    t[273] = "ないはずの結果が返却されました。";
    t[276] = "Database connection failed when starting copy";
    t[277] = "コピー開始時のデータベース接続に失敗しました";
    t[282] = "Invalid protocol state requested. Attempted transaction interleaving is not supported. xid={0}, currentXid={1}, state={2}, flags={3}";
    t[283] = "不正なプロトコル状態が要求されました。Transaction interleaving を試みましたが実装されていません。xid={0}, currentXid={1}, state={2}, flags={3}";
    t[286] = "Invalid stream length {0}.";
    t[287] = "不正なストリーム長 {0}。";
    t[300] = "Finalizing a Connection that was never closed:";
    t[301] = "クローズされていないコネクションの終了処理を行います: ";
    t[304] = "Cannot convert an instance of {0} to type {1}";
    t[305] = "{0} のインスタンスは {1} 型に変換できません";
    t[306] = "A CallableStatement was executed with an invalid number of parameters";
    t[307] = "CallableStatement は不正な数のパラメータで実行されました。";
    t[308] = "Could not read SSL key file {0}.";
    t[309] = "SSL keyファイル {0} を読めませんでした。";
    t[310] = "Illegal UTF-8 sequence: {0} bytes used to encode a {1} byte value: {2}";
    t[311] = "不正なUTF-8シーケンス: {1} バイトの値のエンコードに{0} バイト使用しています: {2}";
    t[316] = "Unknown ResultSet holdability setting: {0}.";
    t[317] = "ResultSet の holdability に対する未知の設定値です: {0}";
    t[320] = "Unexpected error writing large object to database.";
    t[321] = "データベースへのラージオブジェクト書き込み中に想定外のエラーが起きました。";
    t[324] = "Cannot write to copy a byte of value {0}";
    t[325] = "バイト値{0}はコピーストリームへの書き込みはできません";
    t[326] = "Illegal UTF-8 sequence: final value is a surrogate value: {0}";
    t[327] = "不正なUTF-8シーケンス: 変換後の値がサロゲート値です: {0}";
    t[332] = "Ran out of memory retrieving query results.";
    t[333] = "クエリの結果取得中にメモリ不足が起きました。";
    t[334] = "The server requested password-based authentication, but no password was provided.";
    t[335] = "サーバはパスワード・ベースの認証を要求しましたが、パスワードが渡されませんでした。";
    t[336] = "Large Objects may not be used in auto-commit mode.";
    t[337] = "ラージオブジェクトは、自動コミットモードで使うことができません。";
    t[338] = "This ResultSet is closed.";
    t[339] = "この ResultSet はクローズされています。";
    t[340] = "Returning autogenerated keys by column index is not supported.";
    t[341] = "列インデックスで自動生成キーを返すことはサポートされていません。";
    t[348] = "Error during recover";
    t[349] = "recover 処理中のエラー";
    t[350] = "Cannot truncate LOB to a negative length.";
    t[351] = "LOBを負の長さに切り詰めることはできません。";
    t[356] = "Can''t use executeWithFlags(int) on a Statement.";
    t[357] = "executeWithFlags(int) は Statement インスタンスでは使えません。";
    t[358] = "The column name {0} was not found in this ResultSet.";
    t[359] = "この ResultSet に列名 {0} ありません。";
    t[370] = "No SCRAM mechanism(s) advertised by the server";
    t[371] = "サーバは SCRAM認証機構を広告していません";
    t[372] = "No function outputs were registered.";
    t[373] = "関数出力は登録されていません。";
    t[374] = "Unknown XML Source class: {0}";
    t[375] = "未知のXMLソースクラス: {0}";
    t[376] = "Invalid server SCRAM signature";
    t[377] = "不正なサーバSCRAM署名です";
    t[380] = "The sslfactoryarg property may not be empty.";
    t[381] = "プロパティ sslfactoryarg は空であってはなりません。";
    t[386] = "A CallableStatement was declared, but no call to registerOutParameter(1, <some type>) was made.";
    t[387] = "CallableStatementは宣言されましたが、registerOutParameter(1, <some type>) は呼び出されませんでした。";
    t[388] = "Connection has been closed.";
    t[389] = "接続はクローズされました。";
    t[390] = "The JVM claims not to support the encoding: {0}";
    t[391] = "JVMでサポートされないエンコーディングです: {0}";
    t[392] = "This SQLXML object has already been initialized, so you cannot manipulate it further.";
    t[393] = "このSQLXMLオブジェクトは既に初期化済みであるため、これ以上操作できません。";
    t[400] = "The environment variable containing the server's SSL certificate must not be empty.";
    t[401] = "サーバのSSL証明書を指定する環境変数は空であってはなりません。";
    t[404] = "Database connection failed when ending copy";
    t[405] = "コピー操作の終了中にデータベース接続で異常が発生しました";
    t[412] = "Invalid or unsupported by client SCRAM mechanisms";
    t[413] = "不正であるかクライアントのSCRAM機構でサポートされていません";
    t[414] = "Not implemented: Prepare must be issued using the same connection that started the transaction. currentXid={0}, prepare xid={1}";
    t[415] = "実装されていません: Prepareは、トランザクションを開始したものと同じコネクションで発行しなくてはなりません。currentXid={0}, prepare xid={1}";
    t[418] = "{0} function takes three and only three arguments.";
    t[419] = "{0} 関数はちょうど3個の引数を取ります。";
    t[424] = "Invalid UUID data.";
    t[425] = "不正なUUIDデータです。";
    t[428] = "commit called before end. commit xid={0}, state={1}";
    t[429] = "end の前に COMMIT を呼びました commit xid={0}, state={1}";
    t[430] = "Custom type maps are not supported.";
    t[431] = "カスタム型マップはサポートされません。";
    t[436] = "Method {0} is not yet implemented.";
    t[437] = "{0} メソッドはまだ実装されていません。";
    t[442] = "This statement has been closed.";
    t[443] = "このステートメントはクローズされています。";
    t[446] = "Invalid targetServerType value: {0}";
    t[447] = "不正な  targetServerType 値です。{0}.";
    t[448] = "The password callback class provided {0} could not be instantiated.";
    t[449] = "渡されたパスワードコールバッククラス {0} はインスタンス化できませんでした。";
    t[454] = "Currently positioned after the end of the ResultSet.  You cannot call deleteRow() here.";
    t[455] = "ResultSet の最後尾より後ろにいるため、deleteRow() を呼ぶことはできません。";
    t[456] = "Fastpath call {0} - No result was returned and we expected an integer.";
    t[457] = "Fastpath 呼び出し {0} - integer を想定していましたが、結果は返却されませんでした。";
    t[464] = "wasNull cannot be call before fetching a result.";
    t[465] = "wasNullは、結果フェッチ前に呼び出せません。";
    t[470] = "Unsupported Types value: {0}";
    t[471] = "サポートされない Types の値: {0}.";
    t[474] = "Fastpath call {0} - No result was returned and we expected a numeric.";
    t[475] = "Fastpath 呼び出し {0} - numeric を想定していましたが、結果は返却されませんでした。";
    t[476] = "Added parameters index out of range: {0}, number of columns: {1}.";
    t[477] = "パラメータ・インデックスは範囲外です: {0} , カラム数: {1}";
    t[478] = "Unable to find server array type for provided name {0}.";
    t[479] = "指定された名前 {0} のサーバ配列型はありません。";
    t[486] = "CommandComplete expected COPY but got: ";
    t[487] = "CommandComplete はCOPYを想定しましたが、次の結果が返却されました:";
    t[490] = "Position: {0}";
    t[491] = "位置: {0}";
    t[492] = "Conversion to type {0} failed: {1}.";
    t[493] = "{0} への型変換に失敗しました: {1}";
    t[502] = "Failed to create object for: {0}.";
    t[503] = "{0} のオブジェクトの生成に失敗しました。";
    t[504] = "A CallableStatement was executed with nothing returned.";
    t[505] = "CallableStatement が実行されましたがなにも返却されませんでした。";
    t[510] = "Could not read password for SSL key file, console is not available.";
    t[511] = "SSL keyファイルのパスワードを読めませんでした。コンソールは利用できません。";
    t[514] = "Cannot call cancelRowUpdates() when on the insert row.";
    t[515] = "行挿入時に cancelRowUpdates() を呼び出せません。";
    t[518] = "Unable to determine a value for MaxIndexKeys due to missing system catalog data.";
    t[519] = "システムカタログにデータがないため MaxIndexKeys の値を決定できません。";
    t[520] = "Not on the insert row.";
    t[521] = "挿入行上にいません。";
    t[524] = "The column index is out of range: {0}, number of columns: {1}.";
    t[525] = "列インデックスは範囲外です: {0} , 列の数: {1}";
    t[538] = "Unknown Response Type {0}.";
    t[539] = "未知の応答タイプ {0} です。";
    t[540] = "Cannot call deleteRow() when on the insert row.";
    t[541] = "行挿入時に deleteRow() を呼び出せません。";
    t[544] = "Provided Reader failed.";
    t[545] = "渡された Reader で異常が発生しました。";
    t[550] = "Unable to find keywords in the system catalogs.";
    t[551] = "キーワードはシステムカタログにありません。";
    t[552] = "Invalid sslmode value: {0}";
    t[553] = "不正な sslmode 値: {0}";
    t[554] = "Unable to load the class {0} responsible for the datatype {1}";
    t[555] = "データ型 {1} に対応するクラス{0} をロードできません。";
    t[558] = "Expected command status BEGIN, got {0}.";
    t[559] = "BEGINコマンドステータスを想定しましたが、{0} が返却されました。";
    t[564] = "A CallableStatement function was executed and the out parameter {0} was of type {1} however type {2} was registered.";
    t[565] = "CallableStatement 関数が実行され、出力パラメータ {0} は {1} 型 でした。しかし、{2} 型 が登録されました。";
    t[570] = "Cannot convert the column of type {0} to requested type {1}.";
    t[571] = "{0}型のカラムの値を指定の型 {1} に変換できませんでした。";
    t[572] = "No hstore extension installed.";
    t[573] = "hstore 拡張がインストールされてません。";
    t[580] = "Error during one-phase commit. commit xid={0}";
    t[581] = "単一フェーズのCOMMITの処理中のエラー commit xid={0}";
    t[590] = "conversion to {0} from {1} not supported";
    t[591] = "{1} から {0} への変換はサポートされていません。";
    t[594] = "Unsupported value for stringtype parameter: {0}";
    t[595] = "サポートされないstringtypeパラメータ値です: {0}";
    t[600] = "This connection has been closed.";
    t[601] = "このコネクションは既にクローズされています。";
    t[602] = "Connection to {0} refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.";
    t[603] = "{0} への接続が拒絶されました。ホスト名とポート番号が正しいことと、postmaster がTCP/IP接続を受け付けていることを確認してください。";
    t[608] = "Could not open SSL certificate file {0}.";
    t[609] = "SSL証明書ファイル {0} を開けませんでした。";
    t[612] = "{0} parameter value must be an integer but was: {1}";
    t[613] = "パラメータ {0} の値は整数でなければなりませんが指定された値は {1} でした";
    t[616] = "Failed to convert binary xml data to encoding: {0}.";
    t[617] = "バイナリxmlデータのエンコード: {0} への変換に失敗しました。";
    t[626] = "The server''s client_encoding parameter was changed to {0}. The JDBC driver requires client_encoding to be UTF8 for correct operation.";
    t[627] = "サーバの client_encoding パラメータが {0} に変わりました。JDBCドライバが正しく動作するためには、 client_encoding は UTF8 である必要があります。";
    t[630] = "Something unusual has occurred to cause the driver to fail. Please report this exception.";
    t[631] = "何らかの異常によりドライバが動作できません。この例外を報告して下さい。";
    t[636] = "Your security policy has prevented the connection from being attempted.  You probably need to grant the connect java.net.SocketPermission to the database server host and port that you wish to connect to.";
    t[637] = "セキュリティ・ポリシーにより、接続が妨げられました。おそらく、接続先のデータベースサーバのホストとポートに対して java.net.SocketPermission の connect 権限を許可する必要があります。";
    t[638] = "Unexpected packet type during replication: {0}";
    t[639] = "レプリケーション中に想定外のパケット型: {0}";
    t[640] = "Connection has been closed automatically because a new connection was opened for the same PooledConnection or the PooledConnection has been closed.";
    t[641] = "同じ PooledConnection に対して新しい接続をオープンしたか、この PooledConnection がクローズされたため、接続が自動的にクローズされました。";
    t[642] = "Cannot cast an instance of {0} to type {1}";
    t[643] = "{0} のインスタンスは {1} 型へキャストできません";
    t[646] = "Operation requires a scrollable ResultSet, but this ResultSet is FORWARD_ONLY.";
    t[647] = "操作は、スクロール可能なResultSetを必要としますが、このResultSetは、 FORWARD_ONLYです。";
    t[648] = "Fastpath call {0} - No result was returned or wrong size while expecting a long.";
    t[649] = "Fastpath 呼び出し {0} - long を想定していましたが、結果は返却されないかまたは間違った大きさでした。";
    t[650] = "Unable to set network timeout.";
    t[651] = "ネットワークタイムアウトが設定できません。";
    t[662] = "Zero bytes may not occur in identifiers.";
    t[663] = "バイト値0を識別子に含めることはできません。";
    t[664] = "Unable to convert DOMResult SQLXML data to a string.";
    t[665] = "DOMResult SQLXMLデータを文字列に変換することができません。";
    t[678] = "Cannot change transaction isolation level in the middle of a transaction.";
    t[679] = "トランザクションの中でトランザクション分離レベルは変更できません。";
    t[680] = "Error loading default settings from driverconfig.properties";
    t[681] = "driverconfig.properties からの初期設定ロード中のエラー";
    t[682] = "SCRAM authentication failed, server returned error: {0}";
    t[683] = "スクラム認証が失敗しました、サーバはエラーを返却しました:  {0}";
    t[686] = "Unable to create SAXResult for SQLXML.";
    t[687] = "SQLXMLに対するSAXResultを生成できません。";
    t[688] = "Failed to set ClientInfo property: {0}";
    t[689] = "ClientInfo のプロパティの設定に失敗しました: {0}";
    t[692] = "Unable to find name datatype in the system catalogs.";
    t[693] = "name データ型がシステムカタログにありません。";
    t[694] = " (pgjdbc: autodetected server-encoding to be {0}, if the message is not readable, please check database logs and/or host, port, dbname, user, password, pg_hba.conf)";
    t[695] = "(pgjdbc: server-encoding として {0}  を自動検出しました、メッセージが読めない場合はデータベースログおよび host, port, dbname, user, password, pg_dba.conf を確認してください)";
    t[696] = "oid type {0} not known and not a number";
    t[697] = "OID型 {0} は未知でかつ数値でもありません";
    t[700] = "The SocketFactory class provided {0} could not be instantiated.";
    t[701] = "渡された SocketFactoryクラス {0} はインスタンス化できませんでした。";
    t[704] = "Invalid timeout ({0}<0).";
    t[705] = "不正なタイムアウト値 ({0}<0)。";
    t[706] = "LOB positioning offsets start at 1.";
    t[707] = "LOB 位置指定のオフセット値は 1 以上です。";
    t[712] = "Invalid fetch direction constant: {0}.";
    t[713] = "不正なフェッチ方向の定数です: {0}";
    t[716] = "Returning autogenerated keys is not supported.";
    t[717] = "自動生成キーを返すことはサポートされていません。";
    t[732] = "Cannot commit when autoCommit is enabled.";
    t[733] = "autoCommit有効時に、明示的なコミットはできません。";
    t[734] = "Loading the SSL certificate {0} into a KeyManager failed.";
    t[735] = "SSL証明書 {0} をKeyManagerへ読み込めませんでした。";
    t[738] = "ResultSet not positioned properly, perhaps you need to call next.";
    t[739] = "適切な位置にいない ResultSetです。おそらく、nextを呼ぶ必要があります。";
    t[740] = "Requested CopyDual but got {0}";
    t[741] = "CopyDualを要求しましたが {0} が返却されました。";
    t[744] = "The sslfactoryarg property must start with the prefix file:, classpath:, env:, sys:, or -----BEGIN CERTIFICATE-----.";
    t[745] = "プロパティ sslfactoryarg の先頭はプリフィクス file:, classpath:, env:, sys: もしくは -----BEGIN CERTIFICATE----- のいずれかでなければなりません。";
    t[746] = "Unable to parse the count in command completion tag: {0}.";
    t[747] = "コマンド完了タグのカウントをパースできません: {0}";
    t[754] = "Failed to setup DataSource.";
    t[755] = "データソースのセットアップに失敗しました。";
    t[758] = "Too many update results were returned.";
    t[759] = "返却された更新結果が多すぎます。";
    t[762] = "ResultSets with concurrency CONCUR_READ_ONLY cannot be updated.";
    t[763] = "CONCUR_READ_ONLYに設定されている ResultSet は更新できません。";
    t[764] = "Statement has been closed.";
    t[765] = "ステートメントはクローズされました。";
    t[770] = "CopyIn copy direction can't receive data";
    t[771] = "コピー方向 CopyIn はデータを受信できません";
    t[786] = "Unknown Types value.";
    t[787] = "未知の Types の値です。";
    t[788] = "This SQLXML object has not been initialized, so you cannot retrieve data from it.";
    t[789] = "このSQLXMLオブジェクトは初期化されてなかったため、そこからデータを取得できません。";
    t[790] = "Missing expected error response to copy cancel request";
    t[791] = "予期していたコピーの中断要求へのエラー応答がありませんでした";
    t[792] = "An error occurred while setting up the SSL connection.";
    t[793] = "SSL接続のセットアップ中に、エラーが起こりました。";
    t[794] = "Cannot retrieve the id of a named savepoint.";
    t[795] = "名前付き savepoint の id は取得できません。";
    t[796] = "Unable to translate data into the desired encoding.";
    t[797] = "データを指定されたエンコーディングに変換することができません。";
    t[806] = "Parameter of type {0} was registered, but call to get{1} (sqltype={2}) was made.";
    t[807] = "{0} 型のパラメータが登録されましたが、get{1} (sqltype={2}) が呼び出されました。";
    t[812] = "ClientInfo property not supported.";
    t[813] = "ClientInfo プロパティはサポートされていません。";
    t[814] = "Where: {0}";
    t[815] = "場所: {0}";
    t[816] = "{0} function takes two and only two arguments.";
    t[817] = "{0} 関数はちょうど2個の引数を取ります。";
    t[826] = "Got CopyData without an active copy operation";
    t[827] = "実行中のコピー操作がないにもかかわらず CopyData を受け取りました";
    t[828] = "Unable to create StAXResult for SQLXML";
    t[829] = "SQLXMLに対するStAXResultを生成できません。";
    t[832] = "Tried to cancel an inactive copy operation";
    t[833] = "実行中ではないコピー操作の中断を試みました";
    t[834] = "suspend/resume not implemented";
    t[835] = "停止/再開 は実装されていません。";
    t[844] = "{0} function takes two or three arguments.";
    t[845] = "{0} 関数は2個、または3個の引数を取ります。";
    t[846] = "Zero bytes may not occur in string parameters.";
    t[847] = "バイト値0を文字列ラメータに含めることはできません。";
    t[848] = "Could not read SSL root certificate file {0}.";
    t[849] = "SSLルート証明書ファイル {0} を読めませんでした。";
    t[852] = "Bind message length {0} too long.  This can be caused by very large or incorrect length specifications on InputStream parameters.";
    t[853] = "バインドメッセージ長 {0} は長すぎます。InputStreamのパラメータにとても大きな長さ、あるいは不正確な長さが設定されている可能性があります。";
    t[854] = "Bad value for type timestamp/date/time: {1}";
    t[855] = "timestamp/date/time 型に対する不正な値: {1}";
    t[856] = "Illegal UTF-8 sequence: byte {0} of {1} byte sequence is not 10xxxxxx: {2}";
    t[857] = "不正なUTF-8シーケンス: {1} バイトのシーケンス中 {0} バイト目が、10xxxxxx ではありません: {2}";
    t[862] = "No IOException expected from StringBuffer or StringBuilder";
    t[863] = "StringBuffer または StringBuilder からの IOException は想定されていません";
    t[864] = "Unsupported binary encoding of {0}.";
    t[865] = "{0} 型に対するサポートされないバイナリエンコーディング。";
    t[878] = "Can''t refresh the insert row.";
    t[879] = "挿入行を再フェッチすることはできません。";
    t[880] = "This SQLXML object has already been freed.";
    t[881] = "このSQLXMLオブジェクトはすでに解放されています。";
    t[882] = "Fastpath call {0} - No result was returned and we expected a long.";
    t[883] = "Fastpath 呼び出し {0} - long を想定していましたが、結果は返却されませんでした。";
    t[886] = "The parameter index is out of range: {0}, number of parameters: {1}.";
    t[887] = "パラメータのインデックスが範囲外です: {0} , パラメータ数: {1}";
    t[888] = "Internal Position: {0}";
    t[889] = "内部位置: {0}";
    t[896] = "Results cannot be retrieved from a CallableStatement before it is executed.";
    t[897] = "実行前の CallableStatement から結果の取得はできません。";
    t[898] = "Fetch size must be a value greater to or equal to 0.";
    t[899] = "フェッチサイズは、0または、より大きな値でなくてはなりません。";
    t[904] = "Maximum number of rows must be a value grater than or equal to 0.";
    t[905] = "行数の制限値は 0またはより大きな値でなくてはなりません。";
    t[910] = "Cannot cast to boolean: \"{0}\"";
    t[911] = "boolean へのキャストはできません: \"{0}\"";
    t[912] = "Invalid server-first-message: {0}";
    t[913] = "不正な server-first-message: {0}";
    t[914] = "The connection attempt failed.";
    t[915] = "接続試行は失敗しました。";
    t[926] = "Error preparing transaction. prepare xid={0}";
    t[927] = "トランザクションの準備エラー。prepare xid={0}";
    t[930] = "Tried to end inactive copy";
    t[931] = "実行中ではないコピー操作を終了しようとしました";
    t[936] = "Error committing prepared transaction. commit xid={0}, preparedXid={1}, currentXid={2}";
    t[937] = "プリペアドトランザクションの COMMIT 処理中のエラー。commit xid={0}, preparedXid={1}, currentXid={2}";
    t[942] = "Expected an EOF from server, got: {0}";
    t[943] = "サーバからの EOF を期待していましたが、{0} が送られてきました";
    t[944] = "This PooledConnection has already been closed.";
    t[945] = "この PooledConnectionは、すでに閉じられています。";
    t[946] = "Cannot retrieve the name of an unnamed savepoint.";
    t[947] = "無名 savepoint の名前は取得できません。";
    t[948] = "Tried to break lock on database connection";
    t[949] = "データベース接続のロックを破壊しようとしました";
    t[950] = "Database connection failed when writing to copy";
    t[951] = "コピーへの書き込み中にデータベース接続で異常が発生しました";
    t[952] = "The array index is out of range: {0}, number of elements: {1}.";
    t[953] = "配列インデックスが範囲外です: {0} 、要素の数: {1}";
    t[954] = "Unknown type {0}.";
    t[955] = "未知の型 {0}.";
    t[956] = "Interval {0} not yet implemented";
    t[957] = "時間間隔 {0} は実装されていません";
    t[958] = "Network timeout must be a value greater than or equal to 0.";
    t[959] = "ネットワークタイムアウトは、0またはより大きな値でなくてはなりません。";
    t[966] = "No results were returned by the query.";
    t[967] = "クエリは結果を返却しませんでした。";
    t[972] = "Malformed function or procedure escape syntax at offset {0}.";
    t[973] = "関数またはプロシージャの間違ったエスケープ構文が位置{0}で見つかりました。";
    t[978] = "Unable to bind parameter values for statement.";
    t[979] = "ステートメントのパラメータ値をバインドできませんでした。";
    t[984] = "Fastpath call {0} - No result was returned or wrong size while expecting an integer.";
    t[985] = "Fastpath 呼び出し {0} - integer を想定していましたが、結果は返却されないかまたは間違った大きさでした。";
    t[986] = "SCRAM authentication is not supported by this driver. You need JDK >= 8 and pgjdbc >= 42.2.0 (not \".jre\" versions)";
    t[987] = "SCRAM認証はこのドライバではサポートされません。JDK8 以降かつ pgjdbc 42.2.0 以降(\".jre\"のバージョンではありません)が必要です。";
    t[992] = "A connection could not be made using the requested protocol {0}.";
    t[993] = "要求されたプロトコル {0} で接続することができませんでした。";
    t[994] = "Connection attempt timed out.";
    t[995] = "接続試行がタイムアウトしました。";
    t[998] = "Protocol error.  Session setup failed.";
    t[999] = "プロトコルエラー。セッションは準備できませんでした。";
    t[1000] = "The HostnameVerifier class provided {0} could not be instantiated.";
    t[1001] = "与えれた HostnameVerifier クラス {0} はインスタンス化できませんした。";
    t[1002] = "Multiple ResultSets were returned by the query.";
    t[1003] = "クエリの実行により、複数のResultSetが返されました。";
    t[1004] = "Detail: {0}";
    t[1005] = "詳細: {0}";
    t[1006] = "Object is too large to send over the protocol.";
    t[1007] = "オブジェクトが大きすぎてこのプロトコルでは送信できません。";
    t[1008] = "Requested CopyOut but got {0}";
    t[1009] = "CopyOut を要求しましたが {0} が返却されました";
    t[1010] = "Bad value for type {0} : {1}";
    t[1011] = "型 {0} に対する不正な値 : {1}";
    t[1012] = "Could not find a java cryptographic algorithm: {0}.";
    t[1013] = "javaの暗号化アルゴリズム {0} を見つけることができませんでした。";
    t[1016] = "No X509TrustManager found";
    t[1017] = "X509TrustManager が見つかりません";
    t[1018] = "Tried to obtain lock while already holding it";
    t[1019] = "すでに取得中のロックを取得しようとしました";
    t[1020] = "Currently positioned before the start of the ResultSet.  You cannot call deleteRow() here.";
    t[1021] = "RsultSet の開始点より前にいるため、deleteRow() を呼ぶことはできません。";
    t[1022] = "Error rolling back prepared transaction. rollback xid={0}, preparedXid={1}, currentXid={2}";
    t[1023] = "プリペアドトランザクションのロールバック中のエラー rollback xid={0}, preparedXid={1}, currentXid={2}";
    t[1028] = "Properties for the driver contains a non-string value for the key ";
    t[1029] = "このドライバのプロパティでは以下のキーに対して文字列ではない値が設定されています: ";
    t[1032] = "Invalid elements {0}";
    t[1033] = "不正な要素です: {0}";
    t[1034] = "You must specify at least one column value to insert a row.";
    t[1035] = "行挿入には、最低でも１つの列の値が必要です。";
    t[1036] = "The JVM claims not to support the {0} encoding.";
    t[1037] = "JVMは、エンコーディング {0} をサポートしません。";
    t[1038] = "Not implemented: one-phase commit must be issued using the same connection that was used to start it";
    t[1039] = "実装されていません: 単一フェーズのCOMMITは、開始時と同じ接続で発行されなければなりません。";
    t[1040] = "Invalid flags {0}";
    t[1041] = "不正なフラグ {0}";
    t[1046] = "Got CopyBothResponse from server during an active {0}";
    t[1047] = "{0} を実行中のサーバから CopyOutResponse を受け取りました";
    t[1054] = "Cannot establish a savepoint in auto-commit mode.";
    t[1055] = "自動コミットモードでsavepointを作成できません。";
    t[1056] = "Could not decrypt SSL key file {0}.";
    t[1057] = "SSL keyファイル {0} を復号できませんでした。";
    t[1062] = "Preparing already prepared transaction, the prepared xid {0}, prepare xid={1}";
    t[1063] = "すでにプリペアされているトランザクションをプリペアしようとしました、プリペアされている xid={0}, プリペアしようとした xid={1}";
    t[1064] = "Cannot call updateRow() when on the insert row.";
    t[1065] = "挿入行上では updateRow() を呼び出すことができません。";
    t[1068] = "Unexpected packet type during copy: {0}";
    t[1069] = "コピー中の想定外のパケット型です: {0}";
    t[1072] = "Conversion of interval failed";
    t[1073] = "時間間隔の変換に失敗しました。";
    t[1076] = "GSS Authentication failed";
    t[1077] = "GSS認証は失敗しました。";
    t[1084] = "Tried to read from inactive copy";
    t[1085] = "実行中ではないコピーから読み取ろうとしました";
    t[1088] = "Unsupported property name: {0}";
    t[1089] = "サポートされていないプロパティ名: {0}";
    t[1098] = "An error occurred while trying to get the socket timeout.";
    t[1099] = "ソケットタイムアウト取得中にエラーが発生しました。";
    t[1102] = "Loading the SSL root certificate {0} into a TrustManager failed.";
    t[1103] = "SSLルート証明書 {0} をTrustManagerへ読み込めませんでした。";
    t[1108] = "Could not read password for SSL key file by callbackhandler {0}.";
    t[1109] = "callbackhandler {0} で、SSL keyファイルを読めませんでした。";
    t[1110] = "Copying from database failed: {0}";
    t[1111] = "データベースからのコピーに失敗しました: {0}";
    t[1112] = "Cannot tell if path is open or closed: {0}.";
    t[1113] = "経路が開いているか、閉じているか判別できません: {0}";
    t[1116] = "Conversion of money failed.";
    t[1117] = "貨幣金額の変換に失敗しました。";
    t[1118] = "Can''t use relative move methods while on the insert row.";
    t[1119] = "行挿入中に相対移動メソッドは使えません。";
    t[1120] = "Unable to get network timeout.";
    t[1121] = "ネットワークタイムアウトが取得できません。";
    t[1124] = "Invalid character data was found.  This is most likely caused by stored data containing characters that are invalid for the character set the database was created in.  The most common example of this is storing 8bit data in a SQL_ASCII database.";
    t[1125] = "不正な文字データが見つかりました。これはデータベース作成時の文字セットに対して不正な文字を含むデータが格納されているために起きている可能性が高いです。最も一般的な例は、SQL_ASCIIデータベースに8bitデータが保存されている場合です。";
    t[1126] = "Could not find a server with specified targetServerType: {0}";
    t[1127] = "指定された targetServerType のサーバーが見つかりません: {0}";
    t[1128] = "Can''t infer the SQL type to use for an instance of {0}. Use setObject() with an explicit Types value to specify the type to use.";
    t[1129] = "{0} のインスタンスに対して使うべきSQL型を推測できません。明示的な Types 引数をとる setObject() で使うべき型を指定してください。";
    t[1136] = "Cannot reference a savepoint after it has been released.";
    t[1137] = "解放された savepoint は参照できません。";
    t[1138] = "The SSLSocketFactory class provided {0} could not be instantiated.";
    t[1139] = "渡された SSLSocketFactoryクラス {0} はインスタンス化できませんでした。";
    t[1150] = "One-phase commit called for xid {0} but connection was prepared with xid {1}";
    t[1151] = "単相コミットが xid {0} に対してよびだされましたが、コネクションは xid {1} と関連付けられています";
    t[1152] = "This statement does not declare an OUT parameter.  Use '{' ?= call ... '}' to declare one.";
    t[1153] = "このステートメントは、OUTパラメータを宣言していません。'{' ?= call ... '}' を使って宣言して下さい。";
    t[1156] = "The authentication type {0} is not supported. Check that you have configured the pg_hba.conf file to include the client''s IP address or subnet, and that it is using an authentication scheme supported by the driver.";
    t[1157] = "認証タイプ {0} はサポートされません。pg_hba.confでクライアントのIPアドレスまたはサブネットの指定があり、そのエントリでこのドライバがサポートする認証機構を使うように設定されていることを確認してください。";
    t[1160] = "An I/O error occurred while sending to the backend.";
    t[1161] = "バックエンドへの送信中に、入出力エラーが起こりました。";
    t[1162] = "Truncation of large objects is only implemented in 8.3 and later servers.";
    t[1163] = "ラージオブジェクトの切り詰めは、バージョン8.3 以降のサーバでのみ実装されています。";
    t[1168] = "Connection is busy with another transaction";
    t[1169] = "接続は、別のトランザクションを処理中です";
    t[1176] = "Batch entry {0} {1} was aborted: {2}  Call getNextException to see other errors in the batch.";
    t[1177] = "バッチ {0} {1} はアボートしました: {2} このバッチの他のエラーは getNextException を呼び出すことで確認できます。";
    table = t;
  }
  public java.lang.Object handleGetObject (java.lang.String msgid) throws java.util.MissingResourceException {
    int hash_val = msgid.hashCode() & 0x7fffffff;
    int idx = (hash_val % 589) << 1;
    {
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
    int incr = ((hash_val % 587) + 1) << 1;
    for (;;) {
      idx += incr;
      if (idx >= 1178)
        idx -= 1178;
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
  }
  public java.util.Enumeration getKeys () {
    return
      new java.util.Enumeration() {
        private int idx = 0;
        { while (idx < 1178 && table[idx] == null) idx += 2; }
        public boolean hasMoreElements () {
          return (idx < 1178);
        }
        public java.lang.Object nextElement () {
          java.lang.Object key = table[idx];
          do idx += 2; while (idx < 1178 && table[idx] == null);
          return key;
        }
      };
  }
  public java.util.ResourceBundle getParent () {
    return parent;
  }
}
