/* Automatically generated by GNU msgfmt.  Do not modify!  */
package org.postgresql.translation;
public class messages_ja extends java.util.ResourceBundle {
  private static final java.lang.String[] table;
  static {
    java.lang.String[] t = new java.lang.String[1178];
    t[0] = "";
    t[1] = "Project-Id-Version: head-ja\nReport-Msgid-Bugs-To: \nPO-Revision-Date: 2010-04-11 22:58+0900\nLast-Translator: Hiroshi Saito <z-saito@guitar.ocn.ne.jp>\nLanguage-Team: PostgreSQL <z-saito@guitar.ocn.ne.jp>\nLanguage: \nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\nX-Generator: KBabel 1.0.2\nX-Poedit-Language: Japanese\nX-Poedit-Country: Japan\n";
    t[6] = "PostgreSQL LOBs can only index to: {0}";
    t[7] = "PostgreSQL LOB は、インデックス {0} までのみ可能です。 ";
    t[14] = "The server does not support SSL.";
    t[15] = "サーバはSSLをサポートしていません。";
    t[22] = "Error disabling autocommit";
    t[23] = "自動コミットの無効化エラー";
    t[24] = "Hint: {0}";
    t[25] = "ヒント: {0}";
    t[28] = "Interrupted while attempting to connect.";
    t[29] = "接続試行中に割り込みがありました。";
    t[32] = "Can''t use query methods that take a query string on a PreparedStatement.";
    t[33] = "PreparedStatementでクエリ文字を持ったクエリメソッドは使えません。";
    t[34] = "Got CopyInResponse from server during an active {0}";
    t[35] = "活動中のサーバ {0} からCopyInResponseを得ました";
    t[38] = "Cannot rollback when autoCommit is enabled.";
    t[39] = "autoCommit有効時に、明示的なロールバックはできません。";
    t[46] = "DataSource has been closed.";
    t[47] = "データソースは閉じられました。";
    t[54] = "The fastpath function {0} is unknown.";
    t[55] = "{0} は未知の fastpath 関数です。";
    t[56] = "The driver currently does not support COPY operations.";
    t[57] = "現在、ドライバはコピー操作をサポートしません。";
    t[60] = "Illegal UTF-8 sequence: final value is out of range: {0}";
    t[61] = "UTF-8シーケンス違反: 最終値が範囲外です: {0}";
    t[64] = "Prepare called before end. prepare xid={0}, state={1}";
    t[65] = "終了前に\"Prepare\"が呼ばれました prepare xid={0}, state={1}";
    t[66] = "Internal Query: {0}";
    t[67] = "インターナル・クエリ: {0}";
    t[68] = "An unexpected result was returned by a query.";
    t[69] = "クエリによって想定しない結果が返されました。";
    t[82] = "Transaction isolation level {0} not supported.";
    t[83] = "トランザクション隔離レベル{0} はサポートされていません。";
    t[88] = "Requested CopyIn but got {0}";
    t[89] = "CopyInを要求しましたが {0} を得ました。";
    t[90] = "Tried to write to an inactive copy operation";
    t[91] = "動作していないコピー操作で書き込みを試みました。";
    t[94] = "{0} function takes four and only four argument.";
    t[95] = "{0} 関数は、四つの引数のみを用います。";
    t[98] = "Unable to decode xml data.";
    t[99] = "xmlデータを復号化できません。";
    t[100] = "The server''s standard_conforming_strings parameter was reported as {0}. The JDBC driver expected on or off.";
    t[101] = "サーバのstandard_conforming_stringsパラメータは、{0}として報告されました。JDBCドライバは、on または off を想定します。";
    t[102] = "There are no rows in this ResultSet.";
    t[103] = "このResultSetにいかなる行もありません。";
    t[106] = "Server SQLState: {0}";
    t[107] = "サーバ SQLState: {0}";
    t[108] = "This copy stream is closed.";
    t[109] = "コピー・ストリームは閉じられました。";
    t[120] = "The server''s DateStyle parameter was changed to {0}. The JDBC driver requires DateStyle to begin with ISO for correct operation.";
    t[121] = "サーバのDateStyleパラメータは、{0} に変わりました。JDBCドライバは、正しい操作のためISOで開始するDateStyleを要求します。";
    t[122] = "Database connection failed when reading from copy";
    t[123] = "コピーからの読み取り時のデータベース接続に失敗しました。";
    t[124] = "Provided InputStream failed.";
    t[125] = "提供された InputStream は失敗しました。";
    t[142] = "Could not read SSL root certificate file {0}.";
    t[143] = "SSLルート証明書ファイル {0} を読めませんでした。";
    t[144] = "ResultSet is not updateable.  The query that generated this result set must select only one table, and must select all primary keys from that table. See the JDBC 2.1 API Specification, section 5.6 for more details.";
    t[145] = "ResultSetは変更可能ではありません。この結果セットを生成したクエリは、ただ一つのテーブルを選び、そのテーブルから全ての主キーを選ばなくてはいけません。より多くの詳細に関して JDBC 2.1 API仕様、章 5.6 を参照して下さい。";
    t[152] = "The array index is out of range: {0}";
    t[153] = "配列インデックスは、範囲外です: {0}";
    t[154] = "Unexpected command status: {0}.";
    t[155] = "想定外のコマンドステータス: {0}";
    t[156] = "Unknown XML Result class: {0}";
    t[157] = "未知のXML結果クラス: {0}";
    t[160] = "Unexpected copydata from server for {0}";
    t[161] = "{0} のサーバからの思いがけない copydata です。";
    t[162] = "Premature end of input stream, expected {0} bytes, but only read {1}.";
    t[163] = "早すぎた入力ストリームの終了です。{0} バイトが想定されましたが、 {1} のみが読み込まれました。";
    t[168] = "Database connection failed when canceling copy operation";
    t[169] = "コピー操作取り消し時のデータベース接続に失敗しました。";
    t[174] = "No primary key found for table {0}.";
    t[175] = "テーブル {0} の主キーがありません。";
    t[180] = "Enter SSL password: ";
    t[181] = "SSLパスワード入力: ";
    t[182] = "{0} function takes one and only one argument.";
    t[183] = "{0} 関数は、単一の引数のみを用います。";
    t[184] = "Illegal UTF-8 sequence: initial byte is {0}: {1}";
    t[185] = "UTF-8シーケンス違反: 初期バイトは、{0}: {1}";
    t[194] = "Could not find a java cryptographic algorithm: X.509 CertificateFactory not available.";
    t[195] = "javaの暗号化アルゴリズムを見つけることができませんでした。X.509 CertificateFactory は利用できません。";
    t[204] = "No value specified for parameter {0}.";
    t[205] = "パラメータ {0} に値が設定されてません。";
    t[210] = "The hostname {0} could not be verified.";
    t[211] = "ホスト名 {0} は確認できませんでした。";
    t[216] = "Cannot update the ResultSet because it is either before the start or after the end of the results.";
    t[217] = "開始前もしくは終了後であるため、ResultSetを更新することができません。";
    t[218] = "SSL error: {0}";
    t[219] = "SSL エラー: {0}";
    t[220] = "{0} function doesn''t take any argument.";
    t[221] = "{0} 関数は、どのような引数も用いません。";
    t[222] = "Connection is busy with another transaction";
    t[223] = "接続は、別のトランザクションに対応中です。";
    t[228] = "Transaction control methods setAutoCommit(true), commit, rollback and setSavePoint not allowed while an XA transaction is active.";
    t[229] = "トランザクション制御メソッドである setAutoCommit(true), commit, rollback, setSavePoint は、XAトランザクションが有効では利用できません。";
    t[234] = "Could not open SSL root certificate file {0}.";
    t[235] = "SSLルート証明書ファイル {0} を開けませんでした。";
    t[236] = "Received CommandComplete ''{0}'' without an active copy operation";
    t[237] = "活動中のコピー操作なしでCommandComplete ''{0}'' を受け取りました。";
    t[242] = "free() was called on this LOB previously";
    t[243] = "以前に、このLOBに対するfree() は呼ばれました。";
    t[244] = "The hostname {0} could not be verified by hostnameverifier {1}.";
    t[245] = "ホスト名 {0} は、hostnameverifier {1} で確認できませんでした。";
    t[246] = "Heuristic commit/rollback not supported. forget xid={0}";
    t[247] = "サポートされない commit/rollback が見つかりました。forget xid={0}";
    t[252] = "Got CopyOutResponse from server during an active {0}";
    t[253] = "活動中のサーバ {0} からCopyOutResponseを得ました";
    t[258] = "Got {0} error responses to single copy cancel request";
    t[259] = "単一copy取り消し要求に {0} エラー応答を得ました。";
    t[260] = "Read from copy failed.";
    t[261] = "copyからの読み取りに失敗しました。";
    t[264] = "Query timeout must be a value greater than or equals to 0.";
    t[265] = "クエリタイムアウトは、0に等しいか、より大きな値でなくてはなりません。";
    t[272] = "A result was returned when none was expected.";
    t[273] = "結果がないことを想定しましたが、結果が返されました。";
    t[276] = "Database connection failed when starting copy";
    t[277] = "コピー開始時のデータベース接続に失敗しました。";
    t[282] = "Invalid protocol state requested. Attempted transaction interleaving is not supported. xid={0}, currentXid={1}, state={2}, flags={3}";
    t[283] = "Transaction interleaving は実装されていません。xid={0}, currentXid={1}, state={2}, flags={3}";
    t[286] = "Invalid stream length {0}.";
    t[287] = "無効なストリーム長 {0}.";
    t[300] = "Finalizing a Connection that was never closed:";
    t[301] = "接続終了で閉じられませんでした:";
    t[304] = "Cannot convert an instance of {0} to type {1}";
    t[305] = "型 {1} に {0} のインスタンスを変換できません。";
    t[306] = "A CallableStatement was executed with an invalid number of parameters";
    t[307] = "CallableStatementは、不正な数のパラメータで実行されました。";
    t[308] = "Could not read SSL key file {0}.";
    t[309] = "SSL keyファイル {0} を読めませんでした。";
    t[310] = "Illegal UTF-8 sequence: {0} bytes used to encode a {1} byte value: {2}";
    t[311] = "UTF-8シーケンス違反: {0} バイトを、 {1} バイト値のエンコードに使いました: {2}";
    t[316] = "Unknown ResultSet holdability setting: {0}.";
    t[317] = "未知の ResultSet に対するholdability設定です: {0}";
    t[320] = "Unexpected error writing large object to database.";
    t[321] = "データベースへのラージオブジェクト書き込み中に想定外のエラーが起きました。";
    t[324] = "Cannot write to copy a byte of value {0}";
    t[325] = "値{0}のバイトコピーで書き込みができません。";
    t[326] = "Illegal UTF-8 sequence: final value is a surrogate value: {0}";
    t[327] = "UTF-8シーケンス違反: 最終値がサロゲート値です: {0}";
    t[332] = "Ran out of memory retrieving query results.";
    t[333] = "クエリの結果取得にメモリを使い果たしました。";
    t[334] = "The server requested password-based authentication, but no password was provided.";
    t[335] = "サーバはパスワード・ベースの認証を要求しましたが、いかなるパスワードも提供されませんでした。";
    t[336] = "Large Objects may not be used in auto-commit mode.";
    t[337] = "ラージオブジェクトは、自動コミットモードで使うことができません。";
    t[338] = "This ResultSet is closed.";
    t[339] = "ResultSetは閉じられました。";
    t[340] = "Returning autogenerated keys by column index is not supported.";
    t[341] = "列インデックスで自動生成キーを返すことはサポートされていません。";
    t[348] = "Error during recover";
    t[349] = "回復中にエラー";
    t[350] = "Cannot truncate LOB to a negative length.";
    t[351] = "負の値でLOBを削除できません。";
    t[358] = "The column name {0} was not found in this ResultSet.";
    t[359] = "ResultSet に列名 {0} は見つかりませんでした。";
    t[372] = "No function outputs were registered.";
    t[373] = "関数出力は登録されませんでした。";
    t[374] = "Unknown XML Source class: {0}";
    t[375] = "未知のXMLソースクラス: {0}";
    t[386] = "A CallableStatement was declared, but no call to registerOutParameter(1, <some type>) was made.";
    t[387] = "CallableStatementは宣言されましたが、registerOutParameter(1, <some type>) は呼び出されませんでした。";
    t[388] = "Connection has been closed.";
    t[389] = "接続は閉じられました。";
    t[390] = "The JVM claims not to support the encoding: {0}";
    t[391] = "JVMでサポートされないエンコーディングです: {0}";
    t[392] = "This SQLXML object has already been initialized, so you cannot manipulate it further.";
    t[393] = "このSQLXMLオブジェクトは既に初期化されたため、これ以上操作できません。";
    t[404] = "Database connection failed when ending copy";
    t[405] = "コピー終了時のデータベース接続に失敗しました。";
    t[414] = "Not implemented: Prepare must be issued using the same connection that started the transaction. currentXid={0}, prepare xid={1}";
    t[415] = "実装されていません: Prepareは、トランザクションを開始したときと同じ接続で使わなくてはなりません。currentXid={0}, prepare xid={1}";
    t[418] = "{0} function takes three and only three arguments.";
    t[419] = "{0} 関数は、三つの引数のみを用います。";
    t[424] = "Invalid UUID data.";
    t[425] = "無効なUUIDデータです。";
    t[428] = "commit called before end. commit xid={0}, state={1}";
    t[429] = "終了の前に COMMIT を呼びました commit xid={0}, state={1}";
    t[430] = "Custom type maps are not supported.";
    t[431] = "カスタム型マップはサポートされません。";
    t[436] = "Method {0} is not yet implemented.";
    t[437] = "{0} メソッドはまだ実装されていません。";
    t[442] = "This statement has been closed.";
    t[443] = "このステートメントは閉じられました。";
    t[448] = "xid must not be null";
    t[449] = "xidはnullではいけません。";
    t[454] = "Currently positioned after the end of the ResultSet.  You cannot call deleteRow() here.";
    t[455] = "ResultSetの終わりの後に位置していました。ここでdeleteRow()を呼ぶことはできません。";
    t[456] = "Fastpath call {0} - No result was returned and we expected an integer.";
    t[457] = "Fastpath 呼び出し {0} - 整数値を想定しましたが、いかなる結果も返されませんでした。";
    t[464] = "wasNull cannot be call before fetching a result.";
    t[465] = "wasNullは、結果フェッチ前に呼び出せません。";
    t[470] = "Unsupported Types value: {0}";
    t[471] = "サポートされない型の値: {0}.";
    t[478] = "Unable to find server array type for provided name {0}.";
    t[479] = "提供名 {0} で、サーバの配列型を見つけることができません。";
    t[490] = "Position: {0}";
    t[491] = "ポジション: {0}";
    t[492] = "Conversion to type {0} failed: {1}.";
    t[493] = "{0} への型変換は失敗しました: {1}.";
    t[502] = "Failed to create object for: {0}.";
    t[503] = "{0} へのオブジェクト生成に失敗しました。";
    t[504] = "A CallableStatement was executed with nothing returned.";
    t[505] = "CallableStatementは、戻りなしで実行されました。";
    t[510] = "Could not read password for SSL key file, console is not available.";
    t[511] = "SSL keyファイルのパスワードを読めませんでした。コンソールは利用できません。";
    t[514] = "Cannot call cancelRowUpdates() when on the insert row.";
    t[515] = "行挿入時に cancelRowUpdates() を呼び出せません。";
    t[518] = "Unable to determine a value for MaxIndexKeys due to missing system catalog data.";
    t[519] = "間違ったシステム・カタログ・データのためにMaxIndexKeysの値を決めることができません。";
    t[520] = "Not on the insert row.";
    t[521] = "挿入行がありません。";
    t[524] = "The column index is out of range: {0}, number of columns: {1}.";
    t[525] = "列インデックスは範囲外です: {0} , 列の数: {1}";
    t[538] = "Unknown Response Type {0}.";
    t[539] = "未知の応答型 {0} です。";
    t[540] = "Cannot call deleteRow() when on the insert row.";
    t[541] = "行挿入時に deleteRow() を呼び出せません。";
    t[544] = "Provided Reader failed.";
    t[545] = "提供された Reader は失敗しました。";
    t[552] = "Could not initialize SSL context.";
    t[553] = "SSL contextを初期化できませんでした。";
    t[554] = "Unable to load the class {0} responsible for the datatype {1}";
    t[555] = "データ型 {1} に対応するクラス{0} をロードできません。";
    t[558] = "Expected command status BEGIN, got {0}.";
    t[559] = "BEGINコマンドステータスを想定しましたが、{0} を得ました。";
    t[564] = "A CallableStatement function was executed and the out parameter {0} was of type {1} however type {2} was registered.";
    t[565] = "CallableStatement機能が実行され、出力パラメータ {0} は、型 {1} でした。しかし、型 {2} が登録されました。";
    t[572] = "No hstore extension installed.";
    t[573] = "hstore 拡張がインストールされてません。";
    t[580] = "Error during one-phase commit. commit xid={0}";
    t[581] = "単一フェーズのCOMMITの最中にエラー commit xid={0}";
    t[594] = "Unsupported value for stringtype parameter: {0}";
    t[595] = "サポートされないstringtypeパラメータ値です: {0}";
    t[600] = "This connection has been closed.";
    t[601] = "この接続は既に閉じられています。";
    t[608] = "Could not open SSL certificate file {0}.";
    t[609] = "SSL証明書ファイル {0} を開けませんでした。";
    t[612] = "CommandComplete expected COPY but got: ";
    t[613] = "コマンド完了はCOPYを想定しましたが、次の結果を得ました:";
    t[616] = "Failed to convert binary xml data to encoding: {0}.";
    t[617] = "バイナリxmlデータのエンコード: {0} への変換に失敗しました。";
    t[630] = "Something unusual has occurred to cause the driver to fail. Please report this exception.";
    t[631] = "ドライバの失敗を引き起こす異常が起こりました。この例外を報告して下さい。";
    t[636] = "Your security policy has prevented the connection from being attempted.  You probably need to grant the connect java.net.SocketPermission to the database server host and port that you wish to connect to.";
    t[637] = "セキュリティ・ポリシーにより、接続試行は妨げられました。おそらく、データベース・サーバ・ホスト接続のためjava.net.SocketPermissionを許可する必要があります。";
    t[638] = "Statement has been closed.";
    t[639] = "ステートメントは閉じられました。";
    t[640] = "Connection has been closed automatically because a new connection was opened for the same PooledConnection or the PooledConnection has been closed.";
    t[641] = "同じPooledConnectionが開かれたので新しい接続は自動的に閉じられました。または、PooledConnectionは既に閉じられています。";
    t[642] = "Cannot cast an instance of {0} to type {1}";
    t[643] = "インスタンス {0} を型 {1} へキャストできません";
    t[646] = "Operation requires a scrollable ResultSet, but this ResultSet is FORWARD_ONLY.";
    t[647] = "操作は、スクロール可能なResultSetを必要としますが、このResultSetは、 FORWARD_ONLYです。";
    t[662] = "Zero bytes may not occur in identifiers.";
    t[663] = "ゼロ・バイトを識別子に含めることはできません。";
    t[664] = "Unable to convert DOMResult SQLXML data to a string.";
    t[665] = "DOMResult SQLXMLデータを文字列に変えることができません。";
    t[678] = "Cannot change transaction isolation level in the middle of a transaction.";
    t[679] = "トランザクションの最中に隔離レベルを変えることができません。";
    t[680] = "Error loading default settings from driverconfig.properties";
    t[681] = "driverconfig.propertiesによる初期設定のロードエラー。";
    t[686] = "Unable to create SAXResult for SQLXML.";
    t[687] = "SQLXMLに対するSAXResultを生成できません。";
    t[692] = "Unable to find name datatype in the system catalogs.";
    t[693] = "名前データ型をシステムカタログで見つけることができません。";
    t[696] = "oid type {0} not known and not a number";
    t[697] = "数値でない、未知のOID型 {0} です。";
    t[700] = "Error committing prepared transaction. commit xid={0}, preparedXid={1}, currentXid={2}";
    t[701] = "準備トランザクションのコミットエラー。commit xid={0}, preparedXid={1}, currentXid={2}";
    t[706] = "LOB positioning offsets start at 1.";
    t[707] = "LOB オフセット開始位置を 1 としてください。";
    t[712] = "Invalid fetch direction constant: {0}.";
    t[713] = "無効なフェッチ方向の定数です: {0}";
    t[716] = "Returning autogenerated keys is not supported.";
    t[717] = "自動生成キーを返すことはサポートされていません。";
    t[732] = "Cannot commit when autoCommit is enabled.";
    t[733] = "autoCommit有効時に、明示的なコミットはできません。";
    t[734] = "Loading the SSL certificate {0} into a KeyManager failed.";
    t[735] = "SSL証明書 {0} のKeyManagerへの読み込みに失敗しました。";
    t[738] = "ResultSet not positioned properly, perhaps you need to call next.";
    t[739] = "適切な位置を指していないResultSetです。おそらく、nextを呼ぶ必要があります。";
    t[746] = "Interrupted while waiting to obtain lock on database connection";
    t[747] = "データベース接続でロック待ちの最中に割り込みがありました。";
    t[754] = "Failed to setup DataSource.";
    t[755] = "データソースのセットアップに失敗しました。";
    t[758] = "Too many update results were returned.";
    t[759] = "多すぎる更新結果が返されました。";
    t[762] = "ResultSets with concurrency CONCUR_READ_ONLY cannot be updated.";
    t[763] = "CONCUR_READ_ONLYを伴うResultSetsは更新できません。";
    t[770] = "Internal Position: {0}";
    t[771] = "インターナル・ポジション: {0}";
    t[786] = "Unknown Types value.";
    t[787] = "未知の型の値です。";
    t[788] = "This SQLXML object has not been initialized, so you cannot retrieve data from it.";
    t[789] = "このSQLXMLオブジェクトは初期化されてなかったため、そこからデータを取得できません。";
    t[790] = "Missing expected error response to copy cancel request";
    t[791] = "コピー取り消し要求のエラー応答を想定しました。";
    t[792] = "An error occurred while setting up the SSL connection.";
    t[793] = "SSL接続のセットアップ中に、エラーが起こりました。";
    t[794] = "Cannot retrieve the id of a named savepoint.";
    t[795] = "名前の付いたsavepointのidを取得することができません。";
    t[796] = "Unable to translate data into the desired encoding.";
    t[797] = "望む符号化にデータを訳すことができません。";
    t[802] = "Failed to initialize LargeObject API";
    t[803] = "ラージオブジェクトAPIの初期化に失敗しました。";
    t[806] = "Parameter of type {0} was registered, but call to get{1} (sqltype={2}) was made.";
    t[807] = "型 {0}  のパラメータが登録されましたが、get{1} (sqltype={2}) が呼び出されました。";
    t[814] = "Where: {0}";
    t[815] = "場所: {0}";
    t[826] = "Got CopyData without an active copy operation";
    t[827] = "動作中のコピー操作なしでCopyDataを得ました。";
    t[828] = "Unable to create StAXResult for SQLXML";
    t[829] = "SQLXMLに対するStAXResultを生成できません。";
    t[832] = "Tried to cancel an inactive copy operation";
    t[833] = "動作していないコピー操作の取り消しを試みました。";
    t[844] = "{0} function takes two or three arguments.";
    t[845] = "{0} 関数は、二つ、または三つの引数を用います。";
    t[846] = "Zero bytes may not occur in string parameters.";
    t[847] = "ゼロ・バイトを文字列パラメータ中に含めることはできません。";
    t[852] = "Bind message length {0} too long.  This can be caused by very large or incorrect length specifications on InputStream parameters.";
    t[853] = "バインドメッセージ長 {0} は長すぎます。InputStreamパラメータにとても大きな長さ、あるいは不正確な長さが設定されている可能性があります。";
    t[854] = "tried to call end without corresponding start call. state={0}, start xid={1}, currentXid={2}, preparedXid={3}";
    t[855] = "対応する開始呼び出しなしで、終了呼び出しました。state={0}, start xid={1}, currentXid={2}, preparedXid={3}";
    t[856] = "Illegal UTF-8 sequence: byte {0} of {1} byte sequence is not 10xxxxxx: {2}";
    t[857] = "UTF-8シーケンス違反: {1} バイトシーケンスの {0} バイト は、10xxxxxx でありません: {2}";
    t[860] = "Not implemented: 2nd phase commit must be issued using an idle connection. commit xid={0}, currentXid={1}, state={2], transactionState={3}";
    t[861] = "実装されていません: 第二フェーズの COMMIT は、待機接続で使わなくてはなりません。xid={0}, currentXid={1}, state={2], transactionState={3}";
    t[878] = "Can''t refresh the insert row.";
    t[879] = "挿入行を回復することはできません。";
    t[880] = "This SQLXML object has already been freed.";
    t[881] = "このSQLXMLオブジェクトはすでに解放されています。";
    t[882] = "Cannot change transaction read-only property in the middle of a transaction.";
    t[883] = "トランザクションの最中に読み出し専用プロパティを変えることはできません。";
    t[886] = "The parameter index is out of range: {0}, number of parameters: {1}.";
    t[887] = "パラメータ・インデックスは範囲外です: {0} , パラメータ数: {1}";
    t[896] = "Results cannot be retrieved from a CallableStatement before it is executed.";
    t[897] = "実行される前に、CallableStatement から結果を得ることはできません。";
    t[898] = "Fetch size must be a value greater to or equal to 0.";
    t[899] = "フェッチサイズは、0に等しいか、より大きな値でなくてはなりません。";
    t[904] = "Maximum number of rows must be a value grater than or equal to 0.";
    t[905] = "行の最大数は、0に等しいか、より大きな値でなくてはなりません。";
    t[914] = "The connection attempt failed.";
    t[915] = "接続試行は失敗しました。";
    t[926] = "Error preparing transaction. prepare xid={0}";
    t[927] = "トランザクションの準備エラー。prepare xid={0}";
    t[930] = "Tried to end inactive copy";
    t[931] = "動作していないコピーの終了を試みました。";
    t[942] = "Expected an EOF from server, got: {0}";
    t[943] = "サーバからの EOF が想定されましたが、{0} を得ました。";
    t[944] = "This PooledConnection has already been closed.";
    t[945] = "PooledConnectionは、すでに閉じられています。";
    t[946] = "Cannot retrieve the name of an unnamed savepoint.";
    t[947] = "名前のないsavepointの名前を取得することができません。";
    t[948] = "Tried to break lock on database connection";
    t[949] = "データベース接続のロック中断を試みます。";
    t[950] = "Database connection failed when writing to copy";
    t[951] = "コピーへの書き込み時のデータベース接続に失敗しました。";
    t[952] = "The array index is out of range: {0}, number of elements: {1}.";
    t[953] = "配列インデックスは、範囲外です: {0} 、要素の数: {1}";
    t[954] = "Unknown type {0}.";
    t[955] = "未知の型 {0}.";
    t[956] = "Interval {0} not yet implemented";
    t[957] = "間隔 {0} はまだ実装されていません。";
    t[966] = "No results were returned by the query.";
    t[967] = "いかなる結果も、クエリによって返されませんでした。";
    t[970] = "The SSLSocketFactory class provided {0} could not be instantiated.";
    t[971] = "提供のSSLSocketFactoryクラス {0} は、即応しないかもしれません。";
    t[972] = "Malformed function or procedure escape syntax at offset {0}.";
    t[973] = "正しくない関数または手続きは、位置 {0} で文法を逸しました。";
    t[978] = "Unable to bind parameter values for statement.";
    t[979] = "ステートメントのパラメータ値をバインドできません。";
    t[986] = "{0} function takes two and only two arguments.";
    t[987] = "{0} 関数は、二つの引数のみを用います。";
    t[992] = "A connection could not be made using the requested protocol {0}.";
    t[993] = "要求されたプロトコル {0} を使用して接続することができません。";
    t[994] = "Connection attempt timed out.";
    t[995] = "接続試行がタイムアウトしました。";
    t[998] = "Protocol error.  Session setup failed.";
    t[999] = "プロトコルエラー。セッション設定は失敗しました。";
    t[1002] = "Multiple ResultSets were returned by the query.";
    t[1003] = "クエリの実行により、複数のResultSetが返されました。";
    t[1004] = "Detail: {0}";
    t[1005] = "詳細: {0}";
    t[1006] = "Object is too large to send over the protocol.";
    t[1007] = "プロトコルで送信するにはオブジェクトが大きすぎます。";
    t[1008] = "Requested CopyOut but got {0}";
    t[1009] = "CopyOutを要求しましたが {0} を得ました。";
    t[1012] = "Could not find a java cryptographic algorithm: {0}.";
    t[1013] = "javaの暗号化アルゴリズム {0} を見つけることができませんでした。";
    t[1018] = "Tried to obtain lock while already holding it";
    t[1019] = "すでに占有している最中のロック取得です。";
    t[1020] = "Currently positioned before the start of the ResultSet.  You cannot call deleteRow() here.";
    t[1021] = "ResultSetの開始の前に位置していました。ここでdeleteRow()を呼ぶことはできません。";
    t[1022] = "Error rolling back prepared transaction. rollback xid={0}, preparedXid={1}, currentXid={2}";
    t[1023] = "準備トランザクションのロールバックエラー rollback xid={0}, preparedXid={1}, currentXid={2}";
    t[1028] = "Validating connection.";
    t[1029] = "有効確認の接続";
    t[1034] = "You must specify at least one column value to insert a row.";
    t[1035] = "行挿入には、最低でも１つの列の値が必要です。";
    t[1036] = "The JVM claims not to support the {0} encoding.";
    t[1037] = "JVMは、エンコーディング {0} をサポートしません。";
    t[1038] = "Not implemented: one-phase commit must be issued using the same connection that was used to start it";
    t[1039] = "実装されていません: 単一フェーズのCOMMITは、開始時と同じ接続で実行されなければなりません。";
    t[1040] = "Invalid flags {0}";
    t[1041] = "無効なフラグです。{0}";
    t[1046] = "Bad value for type {0} : {1}";
    t[1047] = "型 {0} で不正な値 : {1}";
    t[1054] = "Cannot establish a savepoint in auto-commit mode.";
    t[1055] = "自動コミットモードでsavepointを作成できません。";
    t[1056] = "Could not decrypt SSL key file {0}.";
    t[1057] = "SSL keyファイル {0} を復号できませんでした。";
    t[1064] = "Cannot call updateRow() when on the insert row.";
    t[1065] = "行を挿入したときに、updateRow() を呼び出すことができません。";
    t[1068] = "Unexpected packet type during copy: {0}";
    t[1069] = "コピー中の想定外のパケット型です: {0}";
    t[1072] = "Conversion of interval failed";
    t[1073] = "intervalの変換に失敗しました。";
    t[1076] = "GSS Authentication failed";
    t[1077] = "GSS認証は失敗しました。";
    t[1084] = "Tried to read from inactive copy";
    t[1085] = "動作していないコピーから読み取りを試みました。";
    t[1088] = "Location: File: {0}, Routine: {1}, Line: {2}";
    t[1089] = "場所: ファイル: {0}, ルーチン: {1},行: {2}";
    t[1098] = "suspend/resume not implemented";
    t[1099] = "停止/再開 は実装されていません。";
    t[1102] = "Loading the SSL root certificate {0} into a TrustManager failed.";
    t[1103] = "SSLルート証明書 {0} のTrustManagerへの読み込みに失敗しました。";
    t[1108] = "Could not read password for SSL key file by callbackhandler {0}.";
    t[1109] = "callbackhandler {0} で、SSL keyファイルを読めませんでした。";
    t[1110] = "Copying from database failed: {0}";
    t[1111] = "データベースからコピーに失敗しました: {0}";
    t[1112] = "Cannot tell if path is open or closed: {0}.";
    t[1113] = "path が オープンしているか、クローズしているか判別できません: {0}";
    t[1116] = "Conversion of money failed.";
    t[1117] = "moneyの変換に失敗しました。";
    t[1118] = "Can''t use relative move methods while on the insert row.";
    t[1119] = "行挿入の最中に関連の動作方法を使うことはできません。";
    t[1124] = "Invalid character data was found.  This is most likely caused by stored data containing characters that are invalid for the character set the database was created in.  The most common example of this is storing 8bit data in a SQL_ASCII database.";
    t[1125] = "不正な文字データが見つかりました。これは、恐らく作成されたデータベースの文字セットにとって無効である文字を含むデータが格納されたことによって引き起こされます。最も一般的な例は、SQL_ASCIIデータベースに保存された8bitデータ等です。";
    t[1126] = "The maximum field size must be a value greater than or equal to 0.";
    t[1127] = "最大の項目サイズは、0に等しいか、より大きな値でなくてはなりません。";
    t[1128] = "Can''t infer the SQL type to use for an instance of {0}. Use setObject() with an explicit Types value to specify the type to use.";
    t[1129] = "インスタンス {0} で使うべきSQL型を推測できません。明確な型値を記述した setObject() を使ってください。";
    t[1136] = "Cannot reference a savepoint after it has been released.";
    t[1137] = "savepointは、解放された後で参照することはできません。";
    t[1138] = "ClientInfo property not supported.";
    t[1139] = "ClientInfo プロパティはサポートされていません。";
    t[1152] = "This statement does not declare an OUT parameter.  Use '{' ?= call ... '}' to declare one.";
    t[1153] = "ステートメントは、OUTパラメータを宣言していません。'{' ?= call ... '}' を使って宣言して下さい。";
    t[1156] = "The authentication type {0} is not supported. Check that you have configured the pg_hba.conf file to include the client''s IP address or subnet, and that it is using an authentication scheme supported by the driver.";
    t[1157] = "認証型 {0} はサポートされません。pg_hba.confファイルの構成でクライアントのIPアドレス、サブネットが含まれているか、そしてドライバがサポートする認証機構を使っているかを調べてください。";
    t[1162] = "Truncation of large objects is only implemented in 8.3 and later servers.";
    t[1163] = "ラージオブジェクトの除去は、サーババージョンが 8.3 以上で実装されています。";
    table = t;
  }
  public java.lang.Object handleGetObject (java.lang.String msgid) throws java.util.MissingResourceException {
    int hash_val = msgid.hashCode() & 0x7fffffff;
    int idx = (hash_val % 589) << 1;
    {
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
    int incr = ((hash_val % 587) + 1) << 1;
    for (;;) {
      idx += incr;
      if (idx >= 1178)
        idx -= 1178;
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
  }
  public java.util.Enumeration getKeys () {
    return
      new java.util.Enumeration() {
        private int idx = 0;
        { while (idx < 1178 && table[idx] == null) idx += 2; }
        public boolean hasMoreElements () {
          return (idx < 1178);
        }
        public java.lang.Object nextElement () {
          java.lang.Object key = table[idx];
          do idx += 2; while (idx < 1178 && table[idx] == null);
          return key;
        }
      };
  }
  public java.util.ResourceBundle getParent () {
    return parent;
  }
}
