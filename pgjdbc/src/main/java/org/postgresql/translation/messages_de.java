/* Automatically generated by GNU msgfmt.  Do not modify!  */
package org.postgresql.translation;
public class messages_de extends java.util.ResourceBundle {
  private static final java.lang.String[] table;
  static {
    java.lang.String[] t = new java.lang.String[670];
    t[0] = "";
    t[1] = "Project-Id-Version: head-de\nReport-Msgid-Bugs-To: \nPO-Revision-Date: 2008-09-12 14:22+0200\nLast-Translator: Andre Bialojahn <ab.spamnews@freenet.de>\nLanguage-Team: Deutsch\nLanguage: \nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\nX-Generator: KBabel 1.0.2\nX-Poedit-Language: German\nX-Poedit-Country: GERMANY\n";
    t[4] = "Fastpath call {0} - No result was returned and we expected an integer.";
    t[5] = "Der Fastpath-Aufruf {0} gab kein Ergebnis zurï¿½ck, jedoch wurde ein Integer erwartet.";
    t[10] = "There are no rows in this ResultSet.";
    t[11] = "Es gibt keine Zeilen in diesem ResultSet.";
    t[20] = "Cannot call updateRow() when on the insert row.";
    t[21] = "''updateRow()'' kann in der Einfï¿½gezeile nicht aufgerufen werden.";
    t[22] = "Connection attempt timed out.";
    t[23] = "Keine Verbindung innerhalb des Zeitintervalls mï¿½glich.";
    t[24] = "Unable to bind parameter values for statement.";
    t[25] = "Der Anweisung konnten keine Parameterwerte zugewiesen werden.";
    t[28] = "Maximum number of rows must be a value greater than or equal to 0.";
    t[29] = "Die maximale Zeilenzahl muss ein Wert grï¿½ï¿½er oder gleich Null sein.";
    t[36] = "Cannot change transaction isolation level in the middle of a transaction.";
    t[37] = "Die Transaktions-Trennungsstufe kann nicht wï¿½hrend einer Transaktion verï¿½ndert werden.";
    t[42] = "You must specify at least one column value to insert a row.";
    t[43] = "Sie mï¿½ssen mindestens einen Spaltenwert angeben, um eine Zeile einzufï¿½gen.";
    t[46] = "The column name {0} was not found in this ResultSet.";
    t[47] = "Der Spaltenname {0} wurde in diesem ResultSet nicht gefunden.";
    t[56] = "Conversion of interval failed";
    t[57] = "Die Umwandlung eines Intervalls schlug fehl.";
    t[60] = "Cannot call deleteRow() when on the insert row.";
    t[61] = "''deleteRow()'' kann in der Einfï¿½gezeile nicht aufgerufen werden.";
    t[62] = "Conversion of money failed.";
    t[63] = "Die Umwandlung eines Wï¿½hrungsbetrags schlug fehl.";
    t[64] = "Unexpected command status: {0}.";
    t[65] = "Unerwarteter Befehlsstatus: {0}.";
    t[66] = "An error occurred while setting up the SSL connection.";
    t[67] = "Beim Aufbau der SSL-Verbindung trat ein Fehler auf.";
    t[70] = "Results cannot be retrieved from a CallableStatement before it is executed.";
    t[71] = "Ergebnisse kï¿½nnen nicht von einem CallableStatement abgerufen werden, bevor es ausgefï¿½hrt wurde.";
    t[72] = "The maximum field size must be a value greater than or equal to 0.";
    t[73] = "Die maximale Feldgrï¿½ï¿½e muss ein Wert grï¿½ï¿½er oder gleich Null sein.";
    t[74] = "Something unusual has occurred to cause the driver to fail. Please report this exception.";
    t[75] = "Etwas Ungewï¿½hnliches ist passiert, das den Treiber fehlschlagen lieï¿½. Bitte teilen Sie diesen Fehler mit.";
    t[84] = "Unable to load the class {0} responsible for the datatype {1}";
    t[85] = "Die fï¿½r den Datentyp {1} verantwortliche Klasse {0} konnte nicht geladen werden.";
    t[86] = "Invalid character data was found.  This is most likely caused by stored data containing characters that are invalid for the character set the database was created in.  The most common example of this is storing 8bit data in a SQL_ASCII database.";
    t[87] = "Ungï¿½ltige Zeichendaten.  Das ist hï¿½chstwahrscheinlich von in der Datenbank gespeicherten Zeichen hervorgerufen, die in einer anderen Kodierung vorliegen, als die, in der die Datenbank erstellt wurde.  Das hï¿½ufigste Beispiel dafï¿½r ist es, 8Bit-Daten in SQL_ASCII-Datenbanken abzulegen.";
    t[102] = "No value specified for parameter {0}.";
    t[103] = "Fï¿½r den Parameter {0} wurde kein Wert angegeben.";
    t[116] = "{0} function takes three and only three arguments.";
    t[117] = "Die {0}-Funktion erwartet genau drei Argumente.";
    t[130] = "Can''t refresh the insert row.";
    t[131] = "Die Einfï¿½gezeile kann nicht aufgefrischt werden.";
    t[140] = "Unknown ResultSet holdability setting: {0}.";
    t[141] = "Unbekannte Einstellung fï¿½r die Haltbarkeit des ResultSets: {0}.";
    t[142] = "A connection could not be made using the requested protocol {0}.";
    t[143] = "Es konnte keine Verbindung unter Verwendung des Protokolls {0} hergestellt werden.";
    t[162] = "Method {0} is not yet implemented.";
    t[163] = "Die Methode {0} ist noch nicht implementiert.";
    t[168] = "The server requested password-based authentication, but no password was provided.";
    t[169] = "Der Server verlangt passwortbasierte Authentifizierung, jedoch wurde kein Passwort angegeben.";
    t[172] = "Currently positioned after the end of the ResultSet.  You cannot call deleteRow() here.";
    t[173] = "Die augenblickliche Position ist hinter dem Ende des ResultSets.  Dort kann ''deleteRow()'' nicht aufgerufen werden.";
    t[182] = "PostgreSQL LOBs can only index to: {0}";
    t[183] = "LOBs in PostgreSQL kï¿½nnen nur auf {0} verweisen.";
    t[186] = "Cannot reference a savepoint after it has been released.";
    t[187] = "Ein Rettungspunkt kann nicht angesprochen werden, nach dem er entfernt wurde.";
    t[188] = "Multiple ResultSets were returned by the query.";
    t[189] = "Die Abfrage ergab mehrere ResultSets.";
    t[190] = "Cannot tell if path is open or closed: {0}.";
    t[191] = "Es konnte nicht ermittelt werden, ob der Pfad offen oder geschlossen ist: {0}.";
    t[192] = "Premature end of input stream, expected {0} bytes, but only read {1}.";
    t[193] = "Vorzeitiges Ende des Eingabedatenstroms. Es wurden {0} Bytes erwartet, jedoch nur {1} gelesen.";
    t[196] = "The authentication type {0} is not supported. Check that you have configured the pg_hba.conf file to include the client''s IP address or subnet, and that it is using an authentication scheme supported by the driver.";
    t[197] = "Der Authentifizierungstyp {0} wird nicht unterstï¿½tzt. Stellen Sie sicher, dass die Datei ''pg_hba.conf'' die IP-Adresse oder das Subnetz des Clients enthï¿½lt und dass der Client ein Authentifizierungsschema nutzt, das vom Treiber unterstï¿½tzt wird.";
    t[198] = "The fastpath function {0} is unknown.";
    t[199] = "Die Fastpath-Funktion {0} ist unbekannt.";
    t[202] = "The SSLSocketFactory class provided {0} could not be instantiated.";
    t[203] = "Die von {0} bereitgestellte SSLSocketFactory-Klasse konnte nicht instanziiert werden.";
    t[212] = "Interval {0} not yet implemented";
    t[213] = "Intervall {0} ist noch nicht implementiert.";
    t[214] = "Fetch size must be a value greater to or equal to 0.";
    t[215] = "Die Fetch-Grï¿½ï¿½e muss ein Wert grï¿½ï¿½er oder gleich Null sein.";
    t[218] = "Bad value for type {0} : {1}";
    t[219] = "Unzulï¿½ssiger Wert fï¿½r den Typ {0} : {1}.";
    t[220] = "Finalizing a Connection that was never closed:";
    t[221] = "Eine Connection wurde finalisiert, die nie geschlossen wurde:";
    t[226] = "Too many update results were returned.";
    t[227] = "Zu viele Updateergebnisse wurden zurï¿½ckgegeben.";
    t[230] = "An unexpected result was returned by a query.";
    t[231] = "Eine Abfrage lieferte ein unerwartetes Resultat.";
    t[232] = "LOB positioning offsets start at 1.";
    t[233] = "Positionsoffsets fï¿½r LOBs beginnen bei 1.";
    t[240] = "Cannot retrieve the id of a named savepoint.";
    t[241] = "Die ID eines benamten Rettungspunktes kann nicht ermittelt werden.";
    t[242] = "Unable to find name datatype in the system catalogs.";
    t[243] = "In den Systemkatalogen konnte der Namensdatentyp nicht gefunden werden.";
    t[244] = "{0} function takes two or three arguments.";
    t[245] = "Die {0}-Funktion erwartet zwei oder drei Argumente.";
    t[246] = "Internal Position: {0}";
    t[247] = "Interne Position: {0}";
    t[248] = "No results were returned by the query.";
    t[249] = "Die Abfrage lieferte kein Ergebnis.";
    t[254] = "No primary key found for table {0}.";
    t[255] = "Fï¿½r die Tabelle {0} konnte kein Primï¿½rschlï¿½ssel gefunden werden.";
    t[266] = "This statement does not declare an OUT parameter.  Use '{' ?= call ... '}' to declare one.";
    t[267] = "Diese Anweisung deklariert keinen OUT-Parameter. Benutzen Sie '{' ?= call ... '}' um das zu tun.";
    t[268] = "ResultSet not positioned properly, perhaps you need to call next.";
    t[269] = "Das ResultSet ist nicht richtig positioniert. Eventuell muss ''next'' aufgerufen werden.";
    t[270] = "A result was returned when none was expected.";
    t[271] = "Die Anweisung lieferte ein Ergebnis obwohl keines erwartet wurde.";
    t[272] = "Bind message length {0} too long.  This can be caused by very large or incorrect length specifications on InputStream parameters.";
    t[273] = "Die Nachrichtenlï¿½nge {0} ist zu groï¿½. Das kann von sehr groï¿½en oder inkorrekten Lï¿½ngenangaben eines InputStream-Parameters herrï¿½hren.";
    t[274] = "Your security policy has prevented the connection from being attempted.  You probably need to grant the connect java.net.SocketPermission to the database server host and port that you wish to connect to.";
    t[275] = "Ihre Sicherheitsrichtlinie hat den Versuch des Verbindungsaufbaus verhindert. Sie mï¿½ssen wahrscheinlich der Verbindung zum Datenbankrechner java.net.SocketPermission gewï¿½hren, um den Rechner auf dem gewï¿½hlten Port zu erreichen.";
    t[276] = "A CallableStatement function was executed and the out parameter {0} was of type {1} however type {2} was registered.";
    t[277] = "Eine CallableStatement-Funktion wurde ausgefï¿½hrt und der Rï¿½ckgabewert {0} war vom Typ {1}. Jedoch wurde der Typ {2} dafï¿½r registriert.";
    t[278] = "Cannot retrieve the name of an unnamed savepoint.";
    t[279] = "Der Name eines namenlosen Rettungpunktes kann nicht ermittelt werden.";
    t[284] = "Ran out of memory retrieving query results.";
    t[285] = "Nicht genï¿½gend Speicher beim Abholen der Abfrageergebnisse.";
    t[286] = "{0} function takes two and only two arguments.";
    t[287] = "Die {0}-Funktion erwartet genau zwei Argumente.";
    t[290] = "Zero bytes may not occur in identifiers.";
    t[291] = "Nullbytes dï¿½rfen in Bezeichnern nicht vorkommen.";
    t[292] = "Expected an EOF from server, got: {0}";
    t[293] = "Vom Server wurde ein EOF erwartet, jedoch {0} gelesen.";
    t[294] = "Illegal UTF-8 sequence: initial byte is {0}: {1}";
    t[295] = "Ungï¿½ltige UTF-8-Sequenz: das erste Byte ist {0}: {1}";
    t[298] = "Transaction isolation level {0} not supported.";
    t[299] = "Die Transaktions-Trennungsstufe {0} ist nicht unterstï¿½tzt.";
    t[304] = "free() was called on this LOB previously";
    t[305] = "free() wurde bereits fï¿½r dieses LOB aufgerufen.";
    t[308] = "Cannot change transaction read-only property in the middle of a transaction.";
    t[309] = "Die Nur-Lesen-Eigenschaft einer Transaktion kann nicht wï¿½hrend der Transaktion verï¿½ndert werden.";
    t[310] = "Invalid fetch direction constant: {0}.";
    t[311] = "Unzulï¿½ssige Richtungskonstante bei fetch: {0}.";
    t[312] = "Server SQLState: {0}";
    t[313] = "Server SQLState: {0}";
    t[314] = "Cannot call cancelRowUpdates() when on the insert row.";
    t[315] = "''cancelRowUpdates()'' kann in der Einfï¿½gezeile nicht aufgerufen werden.";
    t[316] = "Parameter of type {0} was registered, but call to get{1} (sqltype={2}) was made.";
    t[317] = "Ein Parameter des Typs {0} wurde registriert, jedoch erfolgte ein Aufruf get{1} (sqltype={2}).";
    t[328] = "ResultSets with concurrency CONCUR_READ_ONLY cannot be updated.";
    t[329] = "ResultSets, deren Zugriffsart CONCUR_READ_ONLY ist, kï¿½nnen nicht aktualisiert werden.";
    t[330] = "The array index is out of range: {0}, number of elements: {1}.";
    t[331] = "Der Arrayindex {0} ist auï¿½erhalb des gï¿½ltigen Bereichs. Vorhandene Elemente: {1}.";
    t[334] = "The JVM claims not to support the encoding: {0}";
    t[335] = "Die JVM behauptet, die Zeichenkodierung {0} nicht zu unterstï¿½tzen.";
    t[346] = "Can''t infer the SQL type to use for an instance of {0}. Use setObject() with an explicit Types value to specify the type to use.";
    t[347] = "Der in SQL fï¿½r eine Instanz von {0} zu verwendende Datentyp kann nicht abgeleitet werden. Benutzen Sie ''setObject()'' mit einem expliziten Typ, um ihn festzulegen.";
    t[348] = "A CallableStatement was executed with nothing returned.";
    t[349] = "Ein CallableStatement wurde ausgefï¿½hrt ohne etwas zurï¿½ckzugeben.";
    t[350] = "xid must not be null";
    t[351] = "Die xid darf nicht null sein.";
    t[360] = "ResultSet is not updateable.  The query that generated this result set must select only one table, and must select all primary keys from that table. See the JDBC 2.1 API Specification, section 5.6 for more details.";
    t[361] = "Das ResultSet kann nicht aktualisiert werden.  Die Abfrage, die es erzeugte, darf nur eine Tabelle und muss darin alle Primï¿½rschlï¿½ssel auswï¿½hlen. Siehe JDBC 2.1 API-Spezifikation, Abschnitt 5.6 fï¿½r mehr Details.";
    t[368] = "Error during recover";
    t[369] = "Beim Wiederherstellen trat ein Fehler auf.";
    t[370] = "Malformed function or procedure escape syntax at offset {0}.";
    t[371] = "Unzulï¿½ssige Syntax fï¿½r ein Funktions- oder Prozedur-Escape an Offset {0}.";
    t[380] = "The connection attempt failed.";
    t[381] = "Der Verbindungsversuch schlug fehl.";
    t[382] = "The server''s standard_conforming_strings parameter was reported as {0}. The JDBC driver expected on or off.";
    t[383] = "Der standard_conforming_strings Parameter des Servers steht auf {0}. Der JDBC-Treiber erwartete on oder off.";
    t[384] = "Where: {0}";
    t[385] = "Wobei: {0}";
    t[386] = "Illegal UTF-8 sequence: {0} bytes used to encode a {1} byte value: {2}";
    t[387] = "Ungï¿½ltige UTF-8-Sequenz: {0} Bytes wurden verwendet um einen {1} Bytewert zu kodieren: {2}";
    t[394] = "The parameter index is out of range: {0}, number of parameters: {1}.";
    t[395] = "Der Parameterindex {0} ist auï¿½erhalb des gï¿½ltigen Bereichs. Es gibt {1} Parameter.";
    t[396] = "{0} function doesn''t take any argument.";
    t[397] = "Die {0}-Funktion akzeptiert kein Argument.";
    t[398] = "Provided InputStream failed.";
    t[399] = "Der bereitgestellte InputStream scheiterte.";
    t[404] = "Invalid stream length {0}.";
    t[405] = "Ungï¿½ltige Lï¿½nge des Datenstroms: {0}.";
    t[408] = "Illegal UTF-8 sequence: byte {0} of {1} byte sequence is not 10xxxxxx: {2}";
    t[409] = "Ungï¿½ltige UTF-8-Sequenz: Byte {0} der {1} Bytesequenz ist nicht 10xxxxxx: {2}";
    t[410] = "Location: File: {0}, Routine: {1}, Line: {2}";
    t[411] = "Ort: Datei: {0}, Routine: {1}, Zeile: {2}.";
    t[412] = "Connection has been closed automatically because a new connection was opened for the same PooledConnection or the PooledConnection has been closed.";
    t[413] = "Die Verbindung wurde automatisch geschlossen, da entweder eine neue Verbindung fï¿½r die gleiche PooledConnection geï¿½ffnet wurde, oder die PooledConnection geschlossen worden ist..";
    t[416] = "Provided Reader failed.";
    t[417] = "Der bereitgestellte Reader scheiterte.";
    t[418] = "suspend/resume not implemented";
    t[419] = "Anhalten/Fortsetzen ist nicht implementiert.";
    t[422] = "Unknown Response Type {0}.";
    t[423] = "Die Antwort weist einen unbekannten Typ auf: {0}.";
    t[428] = "Cannot establish a savepoint in auto-commit mode.";
    t[429] = "Ein Rettungspunkt kann im Modus ''auto-commit'' nicht erstellt werden.";
    t[432] = "Position: {0}";
    t[433] = "Position: {0}";
    t[434] = "Connection has been closed.";
    t[435] = "Die Verbindung wurde geschlossen.";
    t[436] = "DataSource has been closed.";
    t[437] = "Die Datenquelle wurde geschlossen.";
    t[442] = "Unable to determine a value for MaxIndexKeys due to missing system catalog data.";
    t[443] = "Es konnte kein Wert fï¿½r MaxIndexKeys gefunden werden, da die Systemkatalogdaten fehlen.";
    t[444] = "{0} function takes one and only one argument.";
    t[445] = "Die {0}-Funktion erwartet nur genau ein Argument.";
    t[446] = "Hint: {0}";
    t[447] = "Hinweis: {0}";
    t[450] = "Protocol error.  Session setup failed.";
    t[451] = "Protokollfehler.  Die Sitzung konnte nicht gestartet werden.";
    t[452] = "Illegal UTF-8 sequence: final value is out of range: {0}";
    t[453] = "Ungï¿½ltige UTF-8-Sequenz: Der letzte Wert ist auï¿½erhalb des zulï¿½ssigen Bereichs: {0}";
    t[456] = "Interrupted while attempting to connect.";
    t[457] = "Beim Verbindungsversuch trat eine Unterbrechung auf.";
    t[466] = "Error disabling autocommit";
    t[467] = "Fehler beim Abschalten von Autocommit.";
    t[474] = "The array index is out of range: {0}";
    t[475] = "Der Arrayindex ist auï¿½erhalb des gï¿½ltigen Bereichs: {0}.";
    t[484] = "The server''s DateStyle parameter was changed to {0}. The JDBC driver requires DateStyle to begin with ISO for correct operation.";
    t[485] = "Der Parameter ''Date Style'' wurde auf dem Server auf {0} verï¿½ndert. Der JDBC-Treiber setzt fï¿½r korrekte Funktion voraus, dass ''Date Style'' mit ''ISO'' beginnt.";
    t[488] = "Query timeout must be a value greater than or equals to 0.";
    t[489] = "Das Abfragetimeout muss ein Wert grï¿½ï¿½er oder gleich Null sein.";
    t[492] = "Unsupported value for stringtype parameter: {0}";
    t[493] = "Nichtunterstï¿½tzter Wert fï¿½r den Stringparameter: {0}";
    t[494] = "This statement has been closed.";
    t[495] = "Die Anweisung wurde geschlossen.";
    t[498] = "The JVM claims not to support the {0} encoding.";
    t[499] = "Die JVM behauptet, die Zeichenkodierung {0} nicht zu unterstï¿½tzen.";
    t[502] = "Unexpected error writing large object to database.";
    t[503] = "Beim Schreiben eines LargeObjects (LOB) in die Datenbank trat ein unerwarteter Fehler auf.";
    t[520] = "This ResultSet is closed.";
    t[521] = "Dieses ResultSet ist geschlossen.";
    t[522] = "A CallableStatement was executed with an invalid number of parameters";
    t[523] = "Ein CallableStatement wurde mit einer falschen Anzahl Parameter ausgefï¿½hrt.";
    t[524] = "Not implemented: one-phase commit must be issued using the same connection that was used to start it";
    t[525] = "Nicht implementiert: Die einphasige Bestï¿½tigung muss ï¿½ber die selbe Verbindung abgewickelt werden, die verwendet wurde, um sie zu beginnen.";
    t[530] = "Not on the insert row.";
    t[531] = "Nicht in der Einfï¿½gezeile.";
    t[536] = "Unknown Types value.";
    t[537] = "Unbekannter Typ.";
    t[538] = "The column index is out of range: {0}, number of columns: {1}.";
    t[539] = "Der Spaltenindex {0} ist auï¿½erhalb des gï¿½ltigen Bereichs. Anzahl Spalten: {1}.";
    t[540] = "Currently positioned before the start of the ResultSet.  You cannot call deleteRow() here.";
    t[541] = "Die augenblickliche Position ist vor dem Beginn des ResultSets.  Dort kann ''deleteRow()'' nicht aufgerufen werden.";
    t[544] = "Cannot update the ResultSet because it is either before the start or after the end of the results.";
    t[545] = "Das ResultSet kann nicht aktualisiert werden, da es entweder vor oder nach dem Ende der Ergebnisse ist.";
    t[552] = "The server does not support SSL.";
    t[553] = "Der Server unterstï¿½tzt SSL nicht.";
    t[564] = "Detail: {0}";
    t[565] = "Detail: {0}";
    t[566] = "Operation requires a scrollable ResultSet, but this ResultSet is FORWARD_ONLY.";
    t[567] = "Die Operation erfordert ein scrollbares ResultSet, dieses jedoch ist FORWARD_ONLY.";
    t[568] = "Error loading default settings from driverconfig.properties";
    t[569] = "Fehler beim Laden der Voreinstellungen aus driverconfig.properties";
    t[572] = "wasNull cannot be call before fetching a result.";
    t[573] = "wasNull kann nicht aufgerufen werden, bevor ein Ergebnis abgefragt wurde.";
    t[576] = "Unsupported Types value: {0}";
    t[577] = "Unbekannter Typ: {0}.";
    t[578] = "Zero bytes may not occur in string parameters.";
    t[579] = "Stringparameter dï¿½rfen keine Nullbytes enthalten.";
    t[580] = "ClientInfo property not supported.";
    t[581] = "Die ClientInfo-Eigenschaft ist nicht unterstï¿½tzt.";
    t[584] = "Truncation of large objects is only implemented in 8.3 and later servers.";
    t[585] = "Das Abschneiden groï¿½er Objekte ist nur in Versionen nach 8.3 implementiert.";
    t[586] = "Unknown type {0}.";
    t[587] = "Unbekannter Typ {0}.";
    t[590] = "Conversion to type {0} failed: {1}.";
    t[591] = "Die Umwandlung in den Typ {0} schlug fehl: {1}.";
    t[592] = "Can''t use relative move methods while on the insert row.";
    t[593] = "Relative Bewegungen kï¿½nnen in der Einfï¿½gezeile nicht durchgefï¿½hrt werden.";
    t[604] = "{0} function takes four and only four argument.";
    t[605] = "Die {0}-Funktion erwartet genau vier Argumente.";
    t[608] = "Connection is busy with another transaction";
    t[609] = "Die Verbindung ist derzeit mit einer anderen Transaktion beschï¿½ftigt.";
    t[614] = "Expected command status BEGIN, got {0}.";
    t[615] = "Statt des erwarteten Befehlsstatus BEGIN, wurde {0} empfangen.";
    t[620] = "This PooledConnection has already been closed.";
    t[621] = "Diese PooledConnection ist bereits geschlossen worden.";
    t[626] = "A CallableStatement was declared, but no call to registerOutParameter(1, <some type>) was made.";
    t[627] = "Ein CallableStatement wurde deklariert, aber kein Aufruf von ''registerOutParameter(1, <some type>)'' erfolgte.";
    t[630] = "Large Objects may not be used in auto-commit mode.";
    t[631] = "LargeObjects (LOB) dï¿½rfen im Modus ''auto-commit'' nicht verwendet werden.";
    t[638] = "Returning autogenerated keys is not supported.";
    t[639] = "Die Rï¿½ckgabe automatisch generierter Schlï¿½ssel wird nicht unterstï¿½tzt,";
    t[640] = "Cannot convert an instance of {0} to type {1}";
    t[641] = "Die Typwandlung fï¿½r eine Instanz von {0} nach {1} ist nicht mï¿½glich.";
    t[644] = "Failed to create object for: {0}.";
    t[645] = "Erstellung des Objektes schlug fehl fï¿½r: {0}.";
    t[654] = "Unable to translate data into the desired encoding.";
    t[655] = "Die Daten konnten nicht in die gewï¿½nschte Kodierung gewandelt werden.";
    t[658] = "Internal Query: {0}";
    t[659] = "Interne Abfrage: {0}";
    t[660] = "Cannot cast an instance of {0} to type {1}";
    t[661] = "Die Typwandlung fï¿½r eine Instanz von {0} nach {1} ist nicht mï¿½glich.";
    t[664] = "Illegal UTF-8 sequence: final value is a surrogate value: {0}";
    t[665] = "Ungï¿½ltige UTF-8-Sequenz: der letzte Wert ist ein Ersatzwert: {0}";
    t[666] = "Statement has been closed.";
    t[667] = "Die Anweisung wurde geschlossen.";
    table = t;
  }
  public java.lang.Object handleGetObject (java.lang.String msgid) throws java.util.MissingResourceException {
    int hash_val = msgid.hashCode() & 0x7fffffff;
    int idx = (hash_val % 335) << 1;
    {
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
    int incr = ((hash_val % 333) + 1) << 1;
    for (;;) {
      idx += incr;
      if (idx >= 670)
        idx -= 670;
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
  }
  public java.util.Enumeration getKeys () {
    return
      new java.util.Enumeration() {
        private int idx = 0;
        { while (idx < 670 && table[idx] == null) idx += 2; }
        public boolean hasMoreElements () {
          return (idx < 670);
        }
        public java.lang.Object nextElement () {
          java.lang.Object key = table[idx];
          do idx += 2; while (idx < 670 && table[idx] == null);
          return key;
        }
      };
  }
  public java.util.ResourceBundle getParent () {
    return parent;
  }
}
