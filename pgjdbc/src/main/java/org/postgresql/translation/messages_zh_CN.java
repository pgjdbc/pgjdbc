/* Automatically generated by GNU msgfmt.  Do not modify!  */
package org.postgresql.translation;
public class messages_zh_CN extends java.util.ResourceBundle {
  private static final java.lang.String[] table;
  static {
    java.lang.String[] t = new java.lang.String[578];
    t[0] = "";
    t[1] = "Project-Id-Version: PostgreSQL JDBC Driver 8.3\nReport-Msgid-Bugs-To: \nPO-Revision-Date: 2008-01-31 14:34+0800\nLast-Translator: 郭朝益(ChaoYi, Kuo) <Kuo.ChaoYi@gmail.com>\nLanguage-Team: The PostgreSQL Development Team <Kuo.ChaoYi@gmail.com>\nLanguage: \nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\nX-Poedit-Language: Chinese\nX-Poedit-Country: CHINA\nX-Poedit-SourceCharset: utf-8\n";
    t[6] = "Cannot call cancelRowUpdates() when on the insert row.";
    t[7] = "不能在新增的数据列上呼叫 cancelRowUpdates()。";
    t[8] = "The server requested password-based authentication, but no password was provided.";
    t[9] = "服务器要求使用密码验证，但是密码并未提供。";
    t[12] = "Detail: {0}";
    t[13] = "详细：{0}";
    t[16] = "Can''t refresh the insert row.";
    t[17] = "无法重读新增的数据列。";
    t[18] = "Connection has been closed.";
    t[19] = "Connection 已经被关闭。";
    t[24] = "Bad value for type {0} : {1}";
    t[25] = "不良的类型值 {0} : {1}";
    t[36] = "Truncation of large objects is only implemented in 8.3 and later servers.";
    t[37] = "大型对象的截断(Truncation)仅被实作执行在 8.3 和后来的服务器。";
    t[40] = "Cannot retrieve the name of an unnamed savepoint.";
    t[41] = "无法取得未命名储存点(Savepoint)的名称。";
    t[46] = "An error occurred while setting up the SSL connection.";
    t[47] = "进行 SSL 连线时发生错误。";
    t[50] = "suspend/resume not implemented";
    t[51] = "暂停(suspend)/再继续(resume)尚未被实作。";
    t[60] = "{0} function takes one and only one argument.";
    t[61] = "{0} 函式取得一个且仅有一个引数。";
    t[62] = "Conversion to type {0} failed: {1}.";
    t[63] = "转换类型 {0} 失败：{1}。";
    t[66] = "Conversion of money failed.";
    t[67] = "money 转换失败。";
    t[70] = "A result was returned when none was expected.";
    t[71] = "传回预期之外的结果。";
    t[80] = "This PooledConnection has already been closed.";
    t[81] = "这个 PooledConnection 已经被关闭。";
    t[84] = "Multiple ResultSets were returned by the query.";
    t[85] = "查询传回多个 ResultSet。";
    t[90] = "Not on the insert row.";
    t[91] = "不在新增的数据列上。";
    t[94] = "An unexpected result was returned by a query.";
    t[95] = "传回非预期的查询结果。";
    t[102] = "Internal Query: {0}";
    t[103] = "内部查询：{0}";
    t[106] = "The array index is out of range: {0}";
    t[107] = "阵列索引超过许可范围：{0}";
    t[112] = "Connection attempt timed out.";
    t[113] = "Connection 尝试逾时。";
    t[114] = "Unable to find name datatype in the system catalogs.";
    t[115] = "在系统 catalog 中找不到名称数据类型(datatype)。";
    t[116] = "Something unusual has occurred to cause the driver to fail. Please report this exception.";
    t[117] = "不明的原因导致驱动程序造成失败，请回报这个例外。";
    t[120] = "The array index is out of range: {0}, number of elements: {1}.";
    t[121] = "阵列索引超过许可范围：{0}，元素数量：{1}。";
    t[138] = "Invalid flags {0}";
    t[139] = "无效的旗标 flags {0}";
    t[146] = "Unexpected error writing large object to database.";
    t[147] = "将大型对象(large object)写入数据库时发生不明错误。";
    t[162] = "Query timeout must be a value greater than or equals to 0.";
    t[163] = "查询逾时等候时间必须大于或等于 0。";
    t[170] = "Unknown type {0}.";
    t[171] = "不明的类型 {0}";
    t[174] = "The server''s standard_conforming_strings parameter was reported as {0}. The JDBC driver expected on or off.";
    t[175] = "这服务器的 standard_conforming_strings 参数已回报为 {0}，JDBC 驱动程序已预期开启或是关闭。";
    t[176] = "Invalid character data was found.  This is most likely caused by stored data containing characters that are invalid for the character set the database was created in.  The most common example of this is storing 8bit data in a SQL_ASCII database.";
    t[177] = "发现不合法的字元，可能的原因是欲储存的数据中包含数据库的字元集不支援的字码，其中最常见例子的就是将 8 位元数据存入使用 SQL_ASCII 编码的数据库中。";
    t[178] = "The column index is out of range: {0}, number of columns: {1}.";
    t[179] = "栏位索引超过许可范围：{0}，栏位数：{1}。";
    t[180] = "The connection attempt failed.";
    t[181] = "尝试连线已失败。";
    t[182] = "No value specified for parameter {0}.";
    t[183] = "未设定参数值 {0} 的内容。";
    t[190] = "Provided Reader failed.";
    t[191] = "提供的 Reader 已失败。";
    t[194] = "Unsupported value for stringtype parameter: {0}";
    t[195] = "字符类型参数值未被支持：{0}";
    t[198] = "A CallableStatement was declared, but no call to registerOutParameter(1, <some type>) was made.";
    t[199] = "已经宣告 CallableStatement 函式，但是尚未呼叫 registerOutParameter (1, <some_type>) 。";
    t[204] = "Currently positioned before the start of the ResultSet.  You cannot call deleteRow() here.";
    t[205] = "不能在 ResultSet 的第一笔数据之前呼叫 deleteRow()。";
    t[214] = "The maximum field size must be a value greater than or equal to 0.";
    t[215] = "最大栏位容量必须大于或等于 0。";
    t[216] = "Fetch size must be a value greater to or equal to 0.";
    t[217] = "数据读取笔数(fetch size)必须大于或等于 0。";
    t[220] = "PostgreSQL LOBs can only index to: {0}";
    t[221] = "PostgreSQL LOBs 仅能索引到：{0}";
    t[224] = "The JVM claims not to support the encoding: {0}";
    t[225] = "JVM 声明并不支援编码：{0} 。";
    t[226] = "Interval {0} not yet implemented";
    t[227] = "隔绝 {0} 尚未被实作。";
    t[238] = "Fastpath call {0} - No result was returned and we expected an integer.";
    t[239] = "Fastpath 呼叫 {0} - 没有传回值，且应该传回一个整数。";
    t[246] = "ResultSets with concurrency CONCUR_READ_ONLY cannot be updated.";
    t[247] = "ResultSets 与并发同作(Concurrency) CONCUR_READ_ONLY 不能被更新。";
    t[250] = "This statement does not declare an OUT parameter.  Use '{' ?= call ... '}' to declare one.";
    t[251] = "这个 statement 未宣告 OUT 参数，使用 '{' ?= call ... '}' 宣告一个。";
    t[256] = "Cannot reference a savepoint after it has been released.";
    t[257] = "无法参照已经被释放的储存点。";
    t[260] = "Unsupported Types value: {0}";
    t[261] = "未被支持的类型值：{0}";
    t[266] = "Protocol error.  Session setup failed.";
    t[267] = "通讯协定错误，Session 初始化失败。";
    t[274] = "Currently positioned after the end of the ResultSet.  You cannot call deleteRow() here.";
    t[275] = "不能在 ResultSet 的最后一笔数据之后呼叫 deleteRow()。";
    t[278] = "Internal Position: {0}";
    t[279] = "内部位置：{0}";
    t[280] = "Zero bytes may not occur in identifiers.";
    t[281] = "在标识识别符中不存在零位元组。";
    t[288] = "{0} function doesn''t take any argument.";
    t[289] = "{0} 函式无法取得任何的引数。";
    t[300] = "This statement has been closed.";
    t[301] = "这个 statement 已经被关闭。";
    t[318] = "Cannot establish a savepoint in auto-commit mode.";
    t[319] = "在自动确认事物交易模式无法建立储存点(Savepoint)。";
    t[320] = "Position: {0}";
    t[321] = "位置：{0}";
    t[322] = "ResultSet is not updateable.  The query that generated this result set must select only one table, and must select all primary keys from that table. See the JDBC 2.1 API Specification, section 5.6 for more details.";
    t[323] = "不可更新的 ResultSet。用来产生这个 ResultSet 的 SQL 命令只能操作一个数据表，并且必需选择所有主键栏位，详细请参阅 JDBC 2.1 API 规格书 5.6 节。";
    t[330] = "This ResultSet is closed.";
    t[331] = "这个 ResultSet 已经被关闭。";
    t[338] = "Parameter of type {0} was registered, but call to get{1} (sqltype={2}) was made.";
    t[339] = "已注册参数类型 {0}，但是又呼叫了get{1}(sqltype={2})。";
    t[342] = "Transaction isolation level {0} not supported.";
    t[343] = "不支援交易隔绝等级 {0} 。";
    t[344] = "Statement has been closed.";
    t[345] = "Sstatement 已经被关闭。";
    t[352] = "Server SQLState: {0}";
    t[353] = "服务器 SQLState：{0}";
    t[354] = "No primary key found for table {0}.";
    t[355] = "{0} 数据表中未找到主键(Primary key)。";
    t[362] = "Cannot convert an instance of {0} to type {1}";
    t[363] = "无法转换 {0} 到类型 {1} 的实例";
    t[364] = "DataSource has been closed.";
    t[365] = "DataSource 已经被关闭。";
    t[368] = "The column name {0} was not found in this ResultSet.";
    t[369] = "ResultSet 中找不到栏位名称 {0}。";
    t[372] = "ResultSet not positioned properly, perhaps you need to call next.";
    t[373] = "查询结果指标位置不正确，您也许需要呼叫 ResultSet 的 next() 方法。";
    t[378] = "Cannot update the ResultSet because it is either before the start or after the end of the results.";
    t[379] = "无法更新 ResultSet，可能在第一笔数据之前或最未笔数据之后。";
    t[380] = "Method {0} is not yet implemented.";
    t[381] = "这个 {0} 方法尚未被实作。";
    t[382] = "{0} function takes two or three arguments.";
    t[383] = "{0} 函式取得二个或三个引数。";
    t[384] = "The JVM claims not to support the {0} encoding.";
    t[385] = "JVM 声明并不支援 {0} 编码。";
    t[396] = "Unknown Response Type {0}.";
    t[397] = "不明的回应类型 {0}。";
    t[398] = "The parameter index is out of range: {0}, number of parameters: {1}.";
    t[399] = "参数索引超出许可范围：{0}，参数总数：{1}。";
    t[400] = "Where: {0}";
    t[401] = "在位置：{0}";
    t[406] = "Cannot call deleteRow() when on the insert row.";
    t[407] = "不能在新增的数据上呼叫 deleteRow()。";
    t[414] = "{0} function takes four and only four argument.";
    t[415] = "{0} 函式取得四个且仅有四个引数。";
    t[416] = "Unable to translate data into the desired encoding.";
    t[417] = "无法将数据转成目标编码。";
    t[424] = "Can''t use relative move methods while on the insert row.";
    t[425] = "不能在新增的数据列上使用相对位置 move 方法。";
    t[434] = "Invalid stream length {0}.";
    t[435] = "无效的串流长度 {0}.";
    t[436] = "The driver currently does not support COPY operations.";
    t[437] = "驱动程序目前不支援 COPY 操作。";
    t[440] = "Maximum number of rows must be a value grater than or equal to 0.";
    t[441] = "最大数据读取笔数必须大于或等于 0。";
    t[446] = "Failed to create object for: {0}.";
    t[447] = "为 {0} 建立对象失败。";
    t[448] = "{0} function takes three and only three arguments.";
    t[449] = "{0} 函式取得三个且仅有三个引数。";
    t[450] = "Conversion of interval failed";
    t[451] = "隔绝(Interval)转换失败。";
    t[452] = "Cannot tell if path is open or closed: {0}.";
    t[453] = "无法得知 path 是开启或关闭：{0}。";
    t[460] = "Provided InputStream failed.";
    t[461] = "提供的 InputStream 已失败。";
    t[462] = "Invalid fetch direction constant: {0}.";
    t[463] = "无效的 fetch 方向常数：{0}。";
    t[472] = "Invalid protocol state requested. Attempted transaction interleaving is not supported. xid={0}, currentXid={1}, state={2}, flags={3}";
    t[473] = "事物交易隔绝(Transaction interleaving)未被实作。xid={0}, currentXid={1}, state={2}, flags={3}";
    t[474] = "{0} function takes two and only two arguments.";
    t[475] = "{0} 函式取得二个且仅有二个引数。";
    t[476] = "There are no rows in this ResultSet.";
    t[477] = "ResultSet 中找不到数据列。";
    t[478] = "Zero bytes may not occur in string parameters.";
    t[479] = "字符参数不能有 0 个位元组。";
    t[480] = "Cannot call updateRow() when on the insert row.";
    t[481] = "不能在新增的数据列上呼叫 deleteRow()。";
    t[482] = "Connection has been closed automatically because a new connection was opened for the same PooledConnection or the PooledConnection has been closed.";
    t[483] = "Connection 已自动结束，因为一个新的  PooledConnection 连线被开启或者或 PooledConnection 已被关闭。";
    t[488] = "A CallableStatement function was executed and the out parameter {0} was of type {1} however type {2} was registered.";
    t[489] = "一个 CallableStatement 执行函式后输出的参数类型为 {1} 值为 {0}，但是已注册的类型是 {2}。";
    t[494] = "Cannot cast an instance of {0} to type {1}";
    t[495] = "不能转换一个 {0} 实例到类型 {1}";
    t[498] = "Cannot retrieve the id of a named savepoint.";
    t[499] = "无法取得已命名储存点的 id。";
    t[500] = "Cannot change transaction read-only property in the middle of a transaction.";
    t[501] = "不能在事物交易过程中改变事物交易唯读属性。";
    t[502] = "The server does not support SSL.";
    t[503] = "服务器不支援 SSL 连线。";
    t[510] = "A connection could not be made using the requested protocol {0}.";
    t[511] = "无法以要求的通讯协定 {0} 建立连线。";
    t[512] = "The authentication type {0} is not supported. Check that you have configured the pg_hba.conf file to include the client''s IP address or subnet, and that it is using an authentication scheme supported by the driver.";
    t[513] = "不支援 {0} 验证类型。请核对您已经组态 pg_hba.conf 文件包含客户端的IP位址或网路区段，以及驱动程序所支援的验证架构模式已被支援。";
    t[514] = "Malformed function or procedure escape syntax at offset {0}.";
    t[515] = "不正确的函式或程序 escape 语法于 {0}。";
    t[516] = "The server''s DateStyle parameter was changed to {0}. The JDBC driver requires DateStyle to begin with ISO for correct operation.";
    t[517] = "这服务器的 DateStyle 参数被更改成 {0}，JDBC 驱动程序请求需要 DateStyle 以 ISO 开头以正确工作。";
    t[518] = "No results were returned by the query.";
    t[519] = "查询没有传回任何结果。";
    t[520] = "Location: File: {0}, Routine: {1}, Line: {2}";
    t[521] = "位置：文件：{0}，常式：{1}，行：{2}";
    t[526] = "Hint: {0}";
    t[527] = "建议：{0}";
    t[528] = "A CallableStatement was executed with nothing returned.";
    t[529] = "一个 CallableStatement 执行函式后没有传回值。";
    t[530] = "Unknown ResultSet holdability setting: {0}.";
    t[531] = "未知的 ResultSet 可适用的设置：{0}。";
    t[540] = "Cannot change transaction isolation level in the middle of a transaction.";
    t[541] = "不能在事务交易过程中改变事物交易隔绝等级。";
    t[544] = "The fastpath function {0} is unknown.";
    t[545] = "不明的 fastpath 函式 {0}。";
    t[546] = "Can''t use query methods that take a query string on a PreparedStatement.";
    t[547] = "在 PreparedStatement 上不能使用获取查询字符的查询方法。";
    t[556] = "Operation requires a scrollable ResultSet, but this ResultSet is FORWARD_ONLY.";
    t[557] = "操作要求可卷动的 ResultSet，但此 ResultSet 是 FORWARD_ONLY。";
    t[564] = "Unknown Types value.";
    t[565] = "不明的类型值。";
    t[570] = "Large Objects may not be used in auto-commit mode.";
    t[571] = "大型对象无法被使用在自动确认事物交易模式。";
    table = t;
  }
  public java.lang.Object handleGetObject (java.lang.String msgid) throws java.util.MissingResourceException {
    int hash_val = msgid.hashCode() & 0x7fffffff;
    int idx = (hash_val % 289) << 1;
    {
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
    int incr = ((hash_val % 287) + 1) << 1;
    for (;;) {
      idx += incr;
      if (idx >= 578)
        idx -= 578;
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
  }
  public java.util.Enumeration getKeys () {
    return
      new java.util.Enumeration() {
        private int idx = 0;
        { while (idx < 578 && table[idx] == null) idx += 2; }
        public boolean hasMoreElements () {
          return (idx < 578);
        }
        public java.lang.Object nextElement () {
          java.lang.Object key = table[idx];
          do idx += 2; while (idx < 578 && table[idx] == null);
          return key;
        }
      };
  }
  public java.util.ResourceBundle getParent () {
    return parent;
  }
}
