/* Automatically generated by GNU msgfmt.  Do not modify!  */
package org.postgresql.translation;
public class messages_zh_CN extends java.util.ResourceBundle {
  private static final java.lang.String[] table;
  static {
    java.lang.String[] t = new java.lang.String[1426];
    t[0] = "";
    t[1] = "Project-Id-Version: PostgreSQL JDBC Driver 8.3\nReport-Msgid-Bugs-To: \nPO-Revision-Date: 2021-04-14 21:06+0800\nLast-Translator: Feng,zhihao <fengzh.fnst@fujitsu.com>\nLanguage-Team: The PostgreSQL Development Team\nLanguage: zh_CN\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\nX-Poedit-Language: Chinese\nX-Poedit-Country: CHINA\nX-Poedit-SourceCharset: utf-8\n";
    t[2] = "Method {0} is not yet implemented.";
    t[3] = "方法{0}尚未实现。";
    t[10] = "Got {0} error responses to single copy cancel request";
    t[11] = "单个拷贝取消请求收到了{0}个来自服务端的错误响应";
    t[20] = "The array index is out of range: {0}, number of elements: {1}.";
    t[21] = "数组的索引超出范围: {0}，元素数量：{1}。";
    t[26] = "Tried to obtain lock while already holding it";
    t[27] = "尝试获取已经持有的锁";
    t[28] = "Invalid protocol state requested. Attempted transaction interleaving is not supported. xid={0}, currentXid={1}, state={2}, flags={3}";
    t[29] = "请求的协议状态无效。不支持尝试事务交错。xid={0}, 当前事务的Xid={1}，状态={2}，标志位={3}";
    t[34] = "Unsupported property name: {0}";
    t[35] = "不支持的属性名: {0}";
    t[36] = "Unsupported Types value: {0}";
    t[37] = "不支持的类型值: {0}";
    t[44] = "The hostname {0} could not be verified by hostnameverifier {1}.";
    t[45] = "主机名{0}无法通过HostnameVerifier {1}认证。";
    t[52] = "Invalid UUID data.";
    t[53] = "无效的UUID数据。";
    t[54] = "{0} parameter value must be an integer but was: {1}";
    t[55] = "属性{0}的值应是integer类型，实际却是: {1}";
    t[56] = "Copying from database failed: {0}";
    t[57] = "从数据库中拷贝失败: {0}";
    t[58] = "Requested CopyDual but got {0}";
    t[59] = "向服务端请求的是CopyDual，但实际响应的是: {0}";
    t[64] = "Multiple ResultSets were returned by the query.";
    t[65] = "查询返回了多个结果集。";
    t[76] = "Too many update results were returned.";
    t[77] = "返回的更新结果过多。";
    t[84] = "Unable to determine a value for MaxIndexKeys due to missing system catalog data.";
    t[85] = "无法在缺少系统目录数据的情况下确定MaxIndexKeys的值";
    t[90] = "Database connection failed when starting copy";
    t[91] = "在开始拷贝操作时数据库连接发生错误";
    t[94] = "Unknown XML Result class: {0}";
    t[95] = "未知的XML Result类: {0}。";
    t[100] = "The server''s standard_conforming_strings parameter was reported as {0}. The JDBC driver expected on or off.";
    t[101] = "服务器的standard_conforming_strings参数被修改为了{0}。JDBC驱动程序需要将其设置为on或off才能正常动作。";
    t[102] = "Batch entry {0} {1} was aborted: {2}  Call getNextException to see other errors in the batch.";
    t[103] = "批处理条目[{0}] ''{1}''被中止: {2}调用getNextException以查看该批处理中其他条目的错误信息。";
    t[104] = "Protocol error.  Session setup failed.";
    t[105] = "通信协议错误。会话建立失败。";
    t[106] = "This SQLXML object has not been initialized, so you cannot retrieve data from it.";
    t[107] = "该SQLXML对象尚未初始化，无法从中检索数据。";
    t[108] = "Server name validation failed: certificate for host {0} dNSName entries subjectAltName, but none of them match. Assuming server name validation failed";
    t[109] = "服务器名验证失败: 无法为主机{0}的证书匹配任何一个dNSName类型的subjectAltName扩展名。假定服务器名验证失败。";
    t[116] = "Bad value for type {0} : {1}";
    t[117] = "不当的类型值{0} : {1}";
    t[120] = "A CallableStatement was executed with an invalid number of parameters";
    t[121] = "CallableStatement的参数数量不正确。";
    t[124] = "Error preparing transaction. prepare xid={0}";
    t[125] = "事务准备错误。准备事务的xid={0}";
    t[126] = "Can''t use relative move methods while on the insert row.";
    t[127] = "无法在插入行上使用相对位置移动方法。";
    t[130] = "Failed to create object for: {0}.";
    t[131] = "无法创建{0}类型对象。";
    t[136] = "Server does not support temporary replication slots";
    t[137] = "服务端不支持临时的流复制槽";
    t[138] = "Cannot change transaction read-only property in the middle of a transaction.";
    t[139] = "无法在事务处理过程中变更事务的只读属性。";
    t[154] = "{0} function takes three and only three arguments.";
    t[155] = "{0}函数需要为其提供3个参数。";
    t[158] = "One-phase commit called for xid {0} but connection was prepared with xid {1}";
    t[159] = "Xid为{0}的事务调用了一阶段提交，但当前连接已经准备了xid为{1}的事务";
    t[160] = "Validating connection.";
    t[161] = "正在验证连接中。";
    t[166] = "This replication stream has been closed.";
    t[167] = "该复制流已经被关闭。";
    t[168] = "An error occurred while trying to get the socket timeout.";
    t[169] = "尝试获取套接字超时时间时发生错误。";
    t[170] = "Conversion of money failed.";
    t[171] = "money转换失败。";
    t[172] = "Provided Reader failed.";
    t[173] = "提供的Reader发生错误。";
    t[174] = "tried to call end without corresponding start call. state={0}, start xid={1}, currentXid={2}, preparedXid={3}";
    t[175] = "尝试调用end方法，但缺少相应的start方法。state={0}, start的Xid={1}, 当前事务的Xid={2}, 已准备事务的Xid={3}";
    t[178] = "Got CopyBothResponse from server during an active {0}";
    t[179] = "在{0}活动期间从服务端接收到CopyBothResponse";
    t[186] = "Unknown ResultSet holdability setting: {0}.";
    t[187] = "未知的结果集holdability设置: {0}。";
    t[188] = "Not implemented: 2nd phase commit must be issued using an idle connection. commit xid={0}, currentXid={1}, state={2}, transactionState={3}";
    t[189] = "未实装: 二阶段提交必须使用空闲连接。提交事务的xid={0},当前事务的Xid={1}, 状态={2}, 事务状态={3}";
    t[190] = "Invalid server SCRAM signature";
    t[191] = "无效的服务器SCRAM签名";
    t[192] = "The server''s client_encoding parameter was changed to {0}. The JDBC driver requires client_encoding to be UTF8 for correct operation.";
    t[193] = "服务端的client_encoding参数被修改为{0}。JDBC驱动程序需要将client_encoding设置为UTF8才能正常动作。";
    t[198] = "Detail: {0}";
    t[199] = "详细: {0}";
    t[200] = "Unexpected packet type during copy: {0}";
    t[201] = "拷贝时收到预期之外的数据包类型: {0}";
    t[206] = "Transaction isolation level {0} not supported.";
    t[207] = "不支持的事务隔离级别: {0}。";
    t[210] = "The server requested password-based authentication, but no password was provided.";
    t[211] = "服务器要求使用密码验证，但是密码并未提供。";
    t[214] = "Interrupted while attempting to connect.";
    t[215] = "连接尝试被中断。";
    t[216] = "Fetch size must be a value greater to or equal to 0.";
    t[217] = "数据读取大小(fetch size)必须大于或等于 0。";
    t[222] = "No certificates found for hostname {0}";
    t[223] = "没有找到主机名{0}的证书";
    t[228] = "Added parameters index out of range: {0}, number of columns: {1}.";
    t[229] = "新增的参数索引超出范围: {0}，参数总数: {1}。";
    t[230] = "Could not decrypt SSL key file {0}.";
    t[231] = "无法解密SSL密钥文件: {0}";
    t[242] = "Could not initialize SSL context.";
    t[243] = "无法初始化SSL上下文。";
    t[244] = "{0} function takes one and only one argument.";
    t[245] = "{0}函数需要为其提供1个参数。";
    t[248] = "Parameter of type {0} was registered, but call to get{1} (sqltype={2}) was made.";
    t[249] = "注册的是{0}类型参数，却调用get{1}(sqltype={2})获取结果。";
    t[258] = "Conversion of interval failed";
    t[259] = "Interval转换失败。";
    t[262] = "xid must not be null";
    t[263] = "xid不能为空";
    t[264] = "Your security policy has prevented the connection from being attempted.  You probably need to grant the connect java.net.SocketPermission to the database server host and port that you wish to connect to.";
    t[265] = "您的连接被安全策略阻止。你可能需要将java.net.SocketPermission连接权限赋予给你希望连接的数据库服务器的host和port。";
    t[270] = "ClientInfo property not supported.";
    t[271] = "不支持ClientInfo属性。";
    t[272] = "LOB positioning offsets start at 1.";
    t[273] = "LOB的位置偏移从1开始。";
    t[276] = "Tried to write to an inactive copy operation";
    t[277] = "尝试写入数据到一个非活动的拷贝流";
    t[278] = "suspend/resume not implemented";
    t[279] = "suspend/resume尚未实现。";
    t[280] = "Could not read SSL key file {0}.";
    t[281] = "无法读取SSL密钥文件: {0}";
    t[290] = "Transaction control methods setAutoCommit(true), commit, rollback and setSavePoint not allowed while an XA transaction is active.";
    t[291] = "事务控制方法setAutoCommit(true), commit, rollback和setSavePoint无法在XA事务活动期间使用。";
    t[292] = "Unable to find server array type for provided name {0}.";
    t[293] = "找不到{0}对应的的数据库数组类型。";
    t[296] = "Server name validation failed: hostname {0} does not match common name {1}";
    t[297] = "服务器名验证失败: 主机名{0}无法匹配通用名{1}";
    t[300] = "Statement has been closed.";
    t[301] = "Sstatement已经被关闭。";
    t[302] = "The fastpath function {0} is unknown.";
    t[303] = "未知的fastpath函数{0}。";
    t[306] = "The server''s DateStyle parameter was changed to {0}. The JDBC driver requires DateStyle to begin with ISO for correct operation.";
    t[307] = "服务器的DateStyle参数被修改为了{0}。JDBC驱动程序需要以ISO开头的DateStyle才能正常动作。";
    t[308] = "Invalid flags {0}";
    t[309] = "无效的标志: {0}";
    t[324] = "A CallableStatement was declared, but no call to registerOutParameter(1, <some type>) was made.";
    t[325] = "已声明CallableStatement，却没有调用registerOutParameter(1, <some_type>)注册输出参数类型。";
    t[328] = "Cannot commit when autoCommit is enabled.";
    t[329] = "无法在autoCommit有效时显式的提交事务。";
    t[330] = "Database connection failed when writing to copy";
    t[331] = "在写入数据到拷贝流时数据库连接发生错误";
    t[334] = "Hint: {0}";
    t[335] = "建议: {0}";
    t[336] = "Interval {0} not yet implemented";
    t[337] = "Interval {0}尚未实现。";
    t[338] = "Unable to parse X509Certificate for hostname {0}";
    t[339] = "无法解析主机名{0}的X509证书";
    t[346] = "No results were returned by the query.";
    t[347] = "查询没有返回任何结果。";
    t[354] = "Heuristic commit/rollback not supported. forget xid={0}";
    t[355] = "不支持启发式提交/回滚. forget xid={0}";
    t[362] = "Fastpath call {0} - No result was returned or wrong size while expecting an integer.";
    t[363] = "Fastpath调用{0} - 期待返回integer值，但实际没有返回任何结果或返回了错误长度的结果。";
    t[364] = "Cannot cast an instance of {0} to type {1}";
    t[365] = "无法将一个{0}实例强制转换为{1}类型";
    t[366] = "ResultSet not positioned properly, perhaps you need to call next.";
    t[367] = "结果集中游标的位置不正确，您可能需要调用next()方法。";
    t[372] = "Cannot establish a savepoint in auto-commit mode.";
    t[373] = "无法在自动提交模式下建立保存点。";
    t[374] = "Prepare called before end. prepare xid={0}, state={1}";
    t[375] = "end在prepare之前被调用。准备事务的xid={0}, 状态={1}";
    t[378] = "Object is too large to send over the protocol.";
    t[379] = "发送对象过大，无法通过协议发送。";
    t[382] = "You must specify at least one column value to insert a row.";
    t[383] = "必须为行插入操作指定至少一列数据。";
    t[388] = "Query timeout must be a value greater than or equals to 0.";
    t[389] = "查询超时时间的值必须大于或等于0。";
    t[394] = "The SSLSocketFactory class provided {0} could not be instantiated.";
    t[395] = "提供的SSLSocketFactory类<<{0}>>无法被实例化。";
    t[396] = "The parameter index is out of range: {0}, number of parameters: {1}.";
    t[397] = "参数索引超出范围: {0}，参数总数: {1}。";
    t[400] = "This ResultSet is closed.";
    t[401] = "该结果集已经被关闭。";
    t[402] = "Cannot update the ResultSet because it is either before the start or after the end of the results.";
    t[403] = "无法更新结果集，可能由于游标正位于结果集第一条结果之前或最后一条结果之后。";
    t[404] = "SSL error: {0}";
    t[405] = "SSL错误: {0}";
    t[408] = "The column name {0} was not found in this ResultSet.";
    t[409] = "结果集中找不到列名{0}。";
    t[412] = "The authentication type {0} is not supported. Check that you have configured the pg_hba.conf file to include the client''s IP address or subnet, and that it is using an authentication scheme supported by the driver.";
    t[413] = "不支持的{0}认证方式。请确认pg_hba.conf文件已包含客户端的IP地址或网段，以及使用的是驱动程序所支持的认证方式。";
    t[428] = "Got CopyData without an active copy operation";
    t[429] = "在没有活动拷贝流的情况下收到了CopyData";
    t[436] = "PGStream is closed";
    t[437] = "PGStream已经被关闭。";
    t[442] = "This statement has been closed.";
    t[443] = "该statement已经被关闭。";
    t[444] = "Result set exceeded maxResultBuffer limit. Received:  {0}; Current limit: {1}";
    t[445] = "结果集超出了maxResultBuffer的限制。接收到: {0}; 当前限制: {1}";
    t[448] = "oid type {0} not known and not a number";
    t[449] = "未知且不是数值的oid类型: {0}";
    t[452] = "No hstore extension installed.";
    t[453] = "hstore扩展尚未安装。";
    t[454] = "Currently positioned after the end of the ResultSet.  You cannot call deleteRow() here.";
    t[455] = "当前游标位于结果集的最后一条结果之后，无法在此处调用deleteRow()。";
    t[462] = "The column index is out of range: {0}, number of columns: {1}.";
    t[463] = "列索引超出范围: {0}，列数: {1}。";
    t[468] = "Got CopyInResponse from server during an active {0}";
    t[469] = "在{0}活动期间从服务端接收到CopyInResponse";
    t[474] = "Fastpath call {0} - No result was returned and we expected a numeric.";
    t[475] = "Fastpath调用{0} - 期待返回numeric值，但实际没有返回任何结果。";
    t[482] = "An error occurred while setting up the SSL connection.";
    t[483] = "建立SSL连接时发生错误。";
    t[484] = "Could not open SSL certificate file {0}.";
    t[485] = "无法打开SSL证书文件 {0}。";
    t[490] = "free() was called on this LOB previously";
    t[491] = "free()在LOB上已经被调用过";
    t[492] = "Finalizing a Connection that was never closed:";
    t[493] = "正在结束一个未关闭的连接:";
    t[494] = "Unsupported properties: {0}";
    t[495] = "未被支持的propertie属性: {0}";
    t[498] = "Interrupted while waiting to obtain lock on database connection";
    t[499] = "在等待获取锁的过程中被中断";
    t[504] = "The HostnameVerifier class provided {0} could not be instantiated.";
    t[505] = "无法实例化提供的HostnameVerifier类: {0}";
    t[506] = "Unable to create SAXResult for SQLXML.";
    t[507] = "无法为SQLXML创建SAXResult。";
    t[510] = "The server does not support SSL.";
    t[511] = "服务器不支持SSL连接。";
    t[516] = "Error releasing savepoint";
    t[517] = "释放保存点时发生错误";
    t[518] = "Error during one-phase commit. commit xid={0}";
    t[519] = "一阶段提交时发生错误。提交事务的xid={0}";
    t[522] = "Network timeout must be a value greater than or equal to 0.";
    t[523] = "网络超时时间必须大于等于0。";
    t[532] = "Unsupported type conversion to {1}.";
    t[533] = "不支持的类型转换: {1}";
    t[534] = "Premature end of input stream, expected {0} bytes, but only read {1}.";
    t[535] = "输入流过早结束，期待读取{0}个字节，但实际只读取到{1}个字节。";
    t[536] = "Zero bytes may not occur in string parameters.";
    t[537] = "字符参数中不应出现零字节。";
    t[538] = "This connection has been closed.";
    t[539] = "该连接已经被关闭。";
    t[540] = "Cannot call deleteRow() when on the insert row.";
    t[541] = "无法在插入行上调用deleteRow()。";
    t[544] = "Unable to bind parameter values for statement.";
    t[545] = "无法为statement绑定参数";
    t[552] = "Cannot convert an instance of {0} to type {1}";
    t[553] = "无法将一个{0}实例转换为{1}类型";
    t[554] = "Conversion to type {0} failed: {1}.";
    t[555] = "将{1}转换为{0}类型失败。";
    t[556] = "Error loading default settings from driverconfig.properties";
    t[557] = "读取driverconfig.properties中的默认设置时发生错误";
    t[558] = "Expected command status BEGIN, got {0}.";
    t[559] = "期待的CommandStatus是BEGIN，实际却是 {0}。";
    t[564] = "An unexpected result was returned by a query.";
    t[565] = "查询返回了非预期的结果。";
    t[568] = "Something unusual has occurred to cause the driver to fail. Please report this exception.";
    t[569] = "不明的原因导致驱动程序错误，请向我们报告这个错误。";
    t[576] = "One or more ClientInfo failed.";
    t[577] = "一个或一个以上的ClientInfo发生错误。";
    t[578] = "Location: File: {0}, Routine: {1}, Line: {2}";
    t[579] = "位置: 文件: {0}，例程: {1}，行: {2}";
    t[582] = "Unknown type {0}.";
    t[583] = "未知的类型: {0}";
    t[590] = "This SQLXML object has already been freed.";
    t[591] = "该SQLXML对象已经被释放。";
    t[594] = "Unexpected copydata from server for {0}";
    t[595] = "从服务端接收到用于{0}的预期之外的CopyData";
    t[596] = "{0} function takes two or three arguments.";
    t[597] = "{0}函数需要为其提供2或3个参数。";
    t[600] = "Hostname {0} is invalid";
    t[601] = "主机名{0}不可用";
    t[602] = "Connection to {0} refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.";
    t[603] = "{0}的连接被拒绝，请检查主机名称和端口是否正确，并确认postmaster是否正在接收TCP/IP连接。";
    t[612] = "Unsupported binary encoding of {0}.";
    t[613] = "未支持{0}类型的二进制编码。";
    t[616] = "Returning autogenerated keys is not supported.";
    t[617] = "不支持返回自动生成的键";
    t[620] = "Provided InputStream failed.";
    t[621] = "提供的InputStream发生错误。";
    t[626] = "No IOException expected from StringBuffer or StringBuilder";
    t[627] = "不应当有任何IOException从StringBuffer或StringBuilder中抛出";
    t[638] = "Not implemented: one-phase commit must be issued using the same connection that was used to start it";
    t[639] = "未实装: 一阶段提交必须以与开启事务时相同的连接执行。";
    t[640] = "Cannot reference a savepoint after it has been released.";
    t[641] = "无法参照已经被释放的保存点。";
    t[642] = "Ran out of memory retrieving query results.";
    t[643] = "获取查询结果时出现内存不足";
    t[654] = "No primary key found for table {0}.";
    t[655] = "{0}表中找不到主键。";
    t[658] = "Error during recover";
    t[659] = "恢复时发生错误";
    t[660] = "Unable to find pkcs12 keystore.";
    t[661] = "找不到pkcs12的keystore。";
    t[666] = "This copy stream is closed.";
    t[667] = "该拷贝流已经被关闭。";
    t[668] = "Could not open SSL root certificate file {0}.";
    t[669] = "无法打开SSL根证书文件: {0}";
    t[676] = "Invalid sslmode value: {0}";
    t[677] = "无效的sslmode值: {0}";
    t[678] = "Cannot tell if path is open or closed: {0}.";
    t[679] = "无法得知path是否开启: {0}。";
    t[682] = "Illegal UTF-8 sequence: {0} bytes used to encode a {1} byte value: {2}";
    t[683] = "非法的UTF-8序列: {0}个字节被用于编码{1}字节长的值: {2}";
    t[684] = "Unknown XML Source class: {0}";
    t[685] = "未知XML源类: {0}";
    t[686] = "Internal Query: {0}";
    t[687] = "内部查询: {0}";
    t[702] = "Could not find a java cryptographic algorithm: {0}.";
    t[703] = "找不到java加密算法: {0}";
    t[706] = "Connection has been closed automatically because a new connection was opened for the same PooledConnection or the PooledConnection has been closed.";
    t[707] = "连接已经被自动关闭，由于为相同的PooledConnection开启新连接或者PooledConnection已经被关闭。";
    t[708] = "Invalid fetch direction constant: {0}.";
    t[709] = "无效的FetchDirection常量: {0}。";
    t[714] = "Can''t use query methods that take a query string on a PreparedStatement.";
    t[715] = "不能在PreparedStatement上使用带有查询字符串的query方法。";
    t[716] = "SCRAM authentication failed, server returned error: {0}";
    t[717] = "SCRAM认证失败，服务器返回错误: {0}";
    t[722] = "Invalid elements {0}";
    t[723] = "无效的元素 {0}";
    t[736] = "Server name validation pass for {0}, subjectAltName {1}";
    t[737] = "主机名{0}的服务器名验证通过, subjectAltName {1}";
    t[738] = "Not on the insert row.";
    t[739] = "游标没有位于插入行上。";
    t[740] = "Unable to load the class {0} responsible for the datatype {1}";
    t[741] = "无法为数据类型{1}加载类{0}";
    t[752] = "Could not find a java cryptographic algorithm: X.509 CertificateFactory not available.";
    t[753] = "找不到java加密算法: X.509 CertificateFactory不可用。";
    t[756] = "Can''t infer the SQL type to use for an instance of {0}. Use setObject() with an explicit Types value to specify the type to use.";
    t[757] = "无法推测实例{0}的SQL类型。使用setObject()时请明确指定要使用的类型。";
    t[760] = "Invalid server-first-message: {0}";
    t[761] = "无效的server-first-message: {0}";
    t[762] = "No value specified for parameter {0}.";
    t[763] = "未设置参数{0}的值。";
    t[766] = "Fastpath call {0} - No result was returned and we expected an integer.";
    t[767] = "Fastpath调用{0} - 期待返回integer值，但实际没有返回任何结果。";
    t[774] = "Unable to create StAXResult for SQLXML";
    t[775] = "无法为SQLXML创建StAXResult";
    t[798] = "CommandComplete expected COPY but got: ";
    t[799] = "期待的CommandComplete是COPY，实际却是: ";
    t[800] = "Enter SSL password: ";
    t[801] = "请输入SSL密码: ";
    t[802] = "Failed to convert binary xml data to encoding: {0}.";
    t[803] = "无法将二进制xml编码数据转换为: {0}";
    t[804] = "No SCRAM mechanism(s) advertised by the server";
    t[805] = "服务端没有启用的SCRAM认证机制";
    t[818] = "Custom type maps are not supported.";
    t[819] = "不支持自定义的Map类型";
    t[822] = "Illegal UTF-8 sequence: final value is a surrogate value: {0}";
    t[823] = "非法的UTF-8序列: 转换后的值是一个代理值: {0}";
    t[824] = "The SocketFactory class provided {0} could not be instantiated.";
    t[825] = "提供的SocketFactory类<<{0}>>无法被实例化。";
    t[832] = "Large Objects may not be used in auto-commit mode.";
    t[833] = "无法在自动提交模式下使用大对象。";
    t[834] = "Fastpath call {0} - No result was returned or wrong size while expecting a long.";
    t[835] = "Fastpath调用{0} - 期待返回long值，但实际没有返回任何结果或返回了错误长度的结果。";
    t[836] = "Unable to parse certificates for hostname {0}";
    t[837] = "无法解析主机名{0}的证书";
    t[838] = "No X509TrustManager found";
    t[839] = "找不到X509TrustManager";
    t[844] = "Invalid stream length {0}.";
    t[845] = "无效的字符流长度: {0}.";
    t[850] = "The sslfactoryarg property must start with the prefix file:, classpath:, env:, sys:, or -----BEGIN CERTIFICATE-----.";
    t[851] = "sslfactoryarg参数必须以file:, classpath:, env:, sys:,或-----BEGIN CERTIFICATE-----作为前缀。";
    t[852] = "Can''t use executeWithFlags(int) on a Statement.";
    t[853] = "无法在Statement对象上使用executeWithFlags(int)函数";
    t[856] = "Cannot retrieve the id of a named savepoint.";
    t[857] = "无法取得已命名保存点的id。";
    t[860] = "Could not read password for SSL key file by callbackhandler {0}.";
    t[861] = "无法通过callbackhandler {0}为SSL密钥文件读取密码。";
    t[874] = "Tried to break lock on database connection";
    t[875] = "尝试在数据库连接上强制释放锁";
    t[878] = "Unexpected error writing large object to database.";
    t[879] = "将大对象写入数据库时预期之外的错误。";
    t[880] = "Expected an EOF from server, got: {0}";
    t[881] = "期待从服务端接收到EOF，实际接收到: {0}";
    t[886] = "Could not read SSL root certificate file {0}.";
    t[887] = "无法读取SSL根证书文件: {0}";
    t[888] = "This SQLXML object has already been initialized, so you cannot manipulate it further.";
    t[889] = "该SQLXML对象已经被初始化，无法再次执行初始化操作。";
    t[896] = "The array index is out of range: {0}";
    t[897] = "数组的索引超出范围: {0}";
    t[898] = "Unable to set network timeout.";
    t[899] = "无法设置网络超时时间。";
    t[900] = "{0} function takes four and only four argument.";
    t[901] = "{0}函数需要为其提供4个参数。";
    t[904] = "Unable to decode xml data.";
    t[905] = "无法解码xml数据。";
    t[916] = "Bad value for type timestamp/date/time: {1}";
    t[917] = "不当的timestamp/date/time类型值: {1}";
    t[928] = "Illegal UTF-8 sequence: final value is out of range: {0}";
    t[929] = "非法的UTF-8序列: 转换后的值超出范围: {0}";
    t[932] = "Unable to parse the count in command completion tag: {0}.";
    t[933] = "无法解析命令完成标签中的数量: {0}。";
    t[942] = "Read from copy failed.";
    t[943] = "从拷贝流中读取数据失败。";
    t[944] = "Server name validation failed: certificate for hostname {0} has no DNS subjectAltNames, and it CommonName is missing as well";
    t[945] = "服务器名验证失败: 主机名{0}的证书未包含DNS subjectAltNames和CommonName。";
    t[958] = "The password callback class provided {0} could not be instantiated.";
    t[959] = "无法实例化提供的密码回调类: {0}";
    t[960] = "Returning autogenerated keys by column index is not supported.";
    t[961] = "不支持按列索引返回自动生成的键。";
    t[966] = "Properties for the driver contains a non-string value for the key ";
    t[967] = "驱动程序的Propertie属性中存在非字符串的键值";
    t[974] = "Database connection failed when canceling copy operation";
    t[975] = "在取消拷贝操作时数据库连接发生错误";
    t[976] = "DataSource has been closed.";
    t[977] = "DataSource已经被关闭。";
    t[996] = "Unable to get network timeout.";
    t[997] = "无法获取网络超时时间。";
    t[1000] = "A CallableStatement was executed with nothing returned.";
    t[1001] = "CallableStatement执行后没有收到任何返回值。";
    t[1002] = "Can''t refresh the insert row.";
    t[1003] = "无法刷新插入行。";
    t[1004] = "Could not find a server with specified targetServerType: {0}";
    t[1005] = "无法通过targetServerType找到指定的服务器: {0}";
    t[1006] = "This PooledConnection has already been closed.";
    t[1007] = "该PooledConnection已经被关闭。";
    t[1010] = "Cannot call cancelRowUpdates() when on the insert row.";
    t[1011] = "无法在插入行上调用cancelRowUpdates()。";
    t[1012] = "Preparing already prepared transaction, the prepared xid {0}, prepare xid={1}";
    t[1013] = "准备已准备好的事务, 已准备事务的xid {0}, 准备中事务的xid={1}";
    t[1018] = "CopyIn copy direction can't receive data";
    t[1019] = "无法使用CopyIn接收数据";
    t[1024] = "conversion to {0} from {1} not supported";
    t[1025] = "不支持将{1}转换为{0}";
    t[1030] = "An error occurred reading the certificate";
    t[1031] = "读取证书时发生错误";
    t[1032] = "Invalid or unsupported by client SCRAM mechanisms";
    t[1033] = "无效或不支持客户端SCRAM认证机制";
    t[1034] = "Malformed function or procedure escape syntax at offset {0}.";
    t[1035] = "不正确的函数或过程转义语法，位于: {0}";
    t[1038] = "Bind message length {0} too long.  This can be caused by very large or incorrect length specifications on InputStream parameters.";
    t[1039] = "绑定消息的长度({0})过长。这可能是由于InputStream的参数定义过大或定义不正确导致";
    t[1050] = "Cannot change transaction isolation level in the middle of a transaction.";
    t[1051] = "无法在事务处理过程中变更事务的隔离级别。";
    t[1058] = "Internal Position: {0}";
    t[1059] = "内部位置: {0}";
    t[1062] = "No function outputs were registered.";
    t[1063] = "未注册函数的输出参数类型。";
    t[1072] = "Unexpected packet type during replication: {0}";
    t[1073] = "流复制过程中出现期待外的包类型: {0}";
    t[1076] = "Error disabling autocommit";
    t[1077] = "关闭自动提交时发生错误";
    t[1080] = "Requested CopyOut but got {0}";
    t[1081] = "向服务端请求的是CopyOut，但实际响应的是: {0}";
    t[1084] = "Error rolling back prepared transaction. rollback xid={0}, preparedXid={1}, currentXid={2}";
    t[1085] = "已准备事务回滚错误。回滚事务的xid={0},已准备事务的Xid={1},当前事务的Xid={2}";
    t[1086] = "Database connection failed when ending copy";
    t[1087] = "在结束拷贝时数据库连接发生错误";
    t[1090] = "Unsupported value for stringtype parameter: {0}";
    t[1091] = "不支持的stringtype属性值: {0}";
    t[1094] = "The sslfactoryarg property may not be empty.";
    t[1095] = "Property属性sslfactoryarg不能为空。";
    t[1102] = "Loading the SSL root certificate {0} into a TrustManager failed.";
    t[1103] = "无法将SSL根证书加载到TrustManager中。";
    t[1104] = "Illegal UTF-8 sequence: initial byte is {0}: {1}";
    t[1105] = "非法的UTF-8序列: 初始字节为{0}: {1}";
    t[1116] = "The environment variable containing the server's SSL certificate must not be empty.";
    t[1117] = "指定服务端SSL证书的环境变量不能为空。";
    t[1118] = "Connection attempt timed out.";
    t[1119] = "连接尝试超时。";
    t[1130] = "Cannot write to copy a byte of value {0}";
    t[1131] = "无法向拷贝流中写入字节值{0}";
    t[1132] = "Connection has been closed.";
    t[1133] = "Connection已经被关闭。";
    t[1136] = "Could not read password for SSL key file, console is not available.";
    t[1137] = "控制台不可用，无法为SSL密钥文件读取密码。";
    t[1140] = "The JVM claims not to support the encoding: {0}";
    t[1141] = "JVM不支持编码: {0}";
    t[1146] = "Unexpected command status: {0}.";
    t[1147] = "预期之外的CommandStatus: {0}。";
    t[1154] = "Cannot rollback when autoCommit is enabled.";
    t[1155] = "无法在autoCommit有效时显式的回滚事务。";
    t[1158] = "Not implemented: Prepare must be issued using the same connection that started the transaction. currentXid={0}, prepare xid={1}";
    t[1159] = "未实装: Prepare必须以开始该事务的相同连接执行. 当前事务的Xid={0}, 准备中事务的={1}";
    t[1162] = "The connection attempt failed.";
    t[1163] = "连接尝试失败。";
    t[1166] = "Illegal UTF-8 sequence: byte {0} of {1} byte sequence is not 10xxxxxx: {2}";
    t[1167] = "非法的UTF-8序列: {1}字节的序列中的第{0}个字节不为10xxxxxx: {2}";
    t[1178] = "A connection could not be made using the requested protocol {0}.";
    t[1179] = "无法以指定的通信协议{0}建立连接";
    t[1182] = "The system property containing the server's SSL certificate must not be empty.";
    t[1183] = "指定服务端SSL证书的系统属性不能为空。";
    t[1188] = "Cannot call updateRow() when on the insert row.";
    t[1189] = "无法在插入行上调用updateRow()。";
    t[1192] = "Fastpath call {0} - No result was returned and we expected a long.";
    t[1193] = "Fastpath调用{0} - 期待返回long值，但实际没有返回任何结果。";
    t[1198] = "Truncation of large objects is only implemented in 8.3 and later servers.";
    t[1199] = "大对象的截断(Truncation)只适用于8.3及之后的Postgres.";
    t[1200] = "Cannot convert the column of type {0} to requested type {1}.";
    t[1201] = "无法将类型{0}的列转换为{1}类型。";
    t[1204] = "Requested CopyIn but got {0}";
    t[1205] = "向服务端请求的是CopyIn，但实际响应的是: {0}";
    t[1206] = "Cannot cast to boolean: \"{0}\"";
    t[1207] = "无法强制转换为boolean: \"{0}\"";
    t[1212] = "Invalid server-final-message: {0}";
    t[1213] = "无效的server-final-message: {0}";
    t[1214] = "This statement does not declare an OUT parameter.  Use '{' ?= call ... '}' to declare one.";
    t[1215] = "该statement没有声明OUT参数，请使用'{' ?= call ... '}'进行声明。";
    t[1218] = "Cannot truncate LOB to a negative length.";
    t[1219] = "无法将LOB的长度设置为负值。";
    t[1220] = "Zero bytes may not occur in identifiers.";
    t[1221] = "标识符中不应出现零字节。";
    t[1222] = "Unable to convert DOMResult SQLXML data to a string.";
    t[1223] = "无法将DOMResult的SQLXML数据转换为字符串。";
    t[1224] = "Missing expected error response to copy cancel request";
    t[1225] = "缺少拷贝取消请求所对应的来自服务端的错误响应";
    t[1234] = "SCRAM authentication is not supported by this driver. You need JDK >= 8 and pgjdbc >= 42.2.0 (not \".jre\" versions)";
    t[1235] = "驱动程序不支持SCRAM认证。需要JDK >= 8 并且 pgjdbc >= 42.2.0(不是\".jre\"的版本)";
    t[1240] = "Tried to end inactive copy";
    t[1241] = "尝试结束非活动中的拷贝流";
    t[1246] = "A CallableStatement function was executed and the out parameter {0} was of type {1} however type {2} was registered.";
    t[1247] = "CallableStatement函数执行后出参{0}的类型是{1}，但已注册的类型是{2}。";
    t[1250] = "Failed to setup DataSource.";
    t[1251] = "DataSource配置失败。";
    t[1252] = "Loading the SSL certificate {0} into a KeyManager failed.";
    t[1253] = "无法将SSL证书{0}加载到KeyManager。";
    t[1254] = "COPY commands are only supported using the CopyManager API.";
    t[1255] = "COPY命令只支持在CopyManager接口上使用。";
    t[1258] = "Tried to read from inactive copy";
    t[1259] = "尝试从非活动的拷贝流中读取数据";
    t[1260] = "ResultSet is not updateable.  The query that generated this result set must select only one table, and must select all primary keys from that table. See the JDBC 2.1 API Specification, section 5.6 for more details.";
    t[1261] = "不可更新的结果集。生成该结果集的查询语句只能操作单个表，而且必须选择所有的主键。请参考JDBC 2.1 API手册的5.6节查看详细描述。";
    t[1264] = "A result was returned when none was expected.";
    t[1265] = "返回预期之外的结果。";
    t[1266] = "Tried to cancel an inactive copy operation";
    t[1267] = "尝试取消一个非活动的拷贝操作";
    t[1268] = "Server SQLState: {0}";
    t[1269] = "服务器SQLState: {0}";
    t[1272] = "Unable to find keywords in the system catalogs.";
    t[1273] = "无法在系统目录中找到关键字。";
    t[1276] = "Connection is busy with another transaction";
    t[1277] = "连接正在被其他事务占用";
    t[1280] = "ResultSets with concurrency CONCUR_READ_ONLY cannot be updated.";
    t[1281] = "设置了CONCUR_READ_ONLY并发属性的结果集无法被更新。";
    t[1296] = "commit called before end. commit xid={0}, state={1}";
    t[1297] = "end在commit之前被调用。提交事务的xid={0}, 状态={1}";
    t[1308] = "PostgreSQL LOBs can only index to: {0}";
    t[1309] = "PostgreSQL的LOBs仅能索引到：{0}";
    t[1310] = "Where: {0}";
    t[1311] = "在位置: {0}";
    t[1312] = "Unable to find name datatype in the system catalogs.";
    t[1313] = "无法在系统目录中找到name数据类型。";
    t[1314] = "Invalid targetServerType value: {0}";
    t[1315] = "无效的targetServerType值: {0}";
    t[1318] = "Cannot retrieve the name of an unnamed savepoint.";
    t[1319] = "无法取得未命名保存点的名称。";
    t[1320] = "Error committing prepared transaction. commit xid={0}, preparedXid={1}, currentXid={2}";
    t[1321] = "预备事务提交错误。提交事务的xid={0}, 已提交事务的xid={1},当前事务的Xid={2}";
    t[1324] = "Invalid timeout ({0}<0).";
    t[1325] = "无效的超时时间({0}<0).";
    t[1328] = "Operation requires a scrollable ResultSet, but this ResultSet is FORWARD_ONLY.";
    t[1329] = "该操作需要可滚动的结果集，但该结果集被设置为了FORWARD_ONLY。";
    t[1330] = "Results cannot be retrieved from a CallableStatement before it is executed.";
    t[1331] = "在CallableStatement执行之前无法获取结果";
    t[1332] = "wasNull cannot be call before fetching a result.";
    t[1333] = "wasNull无法在结果取得前被调用。";
    t[1336] = "{0} function doesn''t take any argument.";
    t[1337] = "{0}函数不需要为其提供任何参数。";
    t[1340] = "Invalid Inet data.";
    t[1341] = "无效的Inet数据。";
    t[1344] = "Unknown Response Type {0}.";
    t[1345] = "未知的响应消息类型: {0}。";
    t[1346] = "The JVM claims not to support the {0} encoding.";
    t[1347] = "JVM不支持{0}编码。";
    t[1348] = "{0} function takes two and only two arguments.";
    t[1349] = "{0}函数需要为其提供2个参数。";
    t[1350] = "The maximum field size must be a value greater than or equal to 0.";
    t[1351] = "最大字段大小的值必须大于或等于0。";
    t[1352] = "Received CommandComplete ''{0}'' without an active copy operation";
    t[1353] = "在没有活动中的拷贝流的情况下收到了CommandComplete消息''{0}''";
    t[1354] = "Unable to translate data into the desired encoding.";
    t[1355] = "无法将数据转成目标编码。";
    t[1368] = "Got CopyOutResponse from server during an active {0}";
    t[1369] = "在{0}活动期间从服务端接收到CopyOutResponse";
    t[1370] = "Failed to set ClientInfo property: {0}";
    t[1371] = "设置ClientInfo属性失败: {0}。";
    t[1372] = "Invalid character data was found.  This is most likely caused by stored data containing characters that are invalid for the character set the database was created in.  The most common example of this is storing 8bit data in a SQL_ASCII database.";
    t[1373] = "发现不合法的字符。可能是由于存储的数据中包含数据库不支持的字符集。最常见的例子就是将8位数据存储到了SQL_ASCII编码的数据库中。";
    t[1374] = "Unknown Types value.";
    t[1375] = "未知的类型值。";
    t[1376] = " (pgjdbc: autodetected server-encoding to be {0}, if the message is not readable, please check database logs and/or host, port, dbname, user, password, pg_hba.conf)";
    t[1377] = "(pgjdbc: 自动检出服务端编码为{0}，如果消息不可读，请确认数据库日志或host, port, dbname, user, password, pg_hba.conf)";
    t[1386] = "GSS Authentication failed";
    t[1387] = "GSS认证失败";
    t[1390] = "An error occurred while trying to reset the socket timeout.";
    t[1391] = "尝试重置套接字超时时间时发生错误。";
    t[1392] = "Currently positioned before the start of the ResultSet.  You cannot call deleteRow() here.";
    t[1393] = "当前游标位于结果集的第一条结果之前，无法在此处调用deleteRow()。";
    t[1394] = "Current connection does not have an associated xid. prepare xid={0}";
    t[1395] = "当前连接没有相关xid. 准备事务的xid={0}";
    t[1408] = "An I/O error occurred while sending to the backend.";
    t[1409] = "发送数据至后端时发生I/O错误。";
    t[1410] = "WARNING! Required to allocate {0} bytes, which exceeded possible heap memory size. Assigned {1} bytes as limit.";
    t[1411] = "警告！需要分配{0}字节，但这超出了最大可分配的堆内存空间。最大可分配的堆内存空间的上限为{1}字节";
    t[1412] = "Server name validation failed: unable to extract common name from X509Certificate for hostname {0}";
    t[1413] = "服务器名验证失败: 无法从X509证书中提取主机名{0}的通用名。";
    t[1416] = "One-phase commit with unknown xid. commit xid={0}, currentXid={1}";
    t[1417] = "未知xid的一阶段提交。提交事务的xid={0}, 当前事务的Xid={1}";
    t[1420] = "Position: {0}";
    t[1421] = "位置: {0}";
    t[1422] = "There are no rows in this ResultSet.";
    t[1423] = "该结果集中没有任何数据行。";
    t[1424] = "Database connection failed when reading from copy";
    t[1425] = "在从拷贝流中读取数据时数据库连接发生错误";
    table = t;
  }
  public java.lang.Object handleGetObject (java.lang.String msgid) throws java.util.MissingResourceException {
    int hash_val = msgid.hashCode() & 0x7fffffff;
    int idx = (hash_val % 713) << 1;
    {
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
    int incr = ((hash_val % 711) + 1) << 1;
    for (;;) {
      idx += incr;
      if (idx >= 1426)
        idx -= 1426;
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
  }
  public java.util.Enumeration getKeys () {
    return
      new java.util.Enumeration() {
        private int idx = 0;
        { while (idx < 1426 && table[idx] == null) idx += 2; }
        public boolean hasMoreElements () {
          return (idx < 1426);
        }
        public java.lang.Object nextElement () {
          java.lang.Object key = table[idx];
          do idx += 2; while (idx < 1426 && table[idx] == null);
          return key;
        }
      };
  }
  public java.util.ResourceBundle getParent () {
    return parent;
  }
}
