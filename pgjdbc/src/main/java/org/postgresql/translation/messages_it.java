/* Automatically generated by GNU msgfmt.  Do not modify!  */
package org.postgresql.translation;
public class messages_it extends java.util.ResourceBundle {
  private static final java.lang.String[] table;
  static {
    java.lang.String[] t = new java.lang.String[506];
    t[0] = "";
    t[1] = "Project-Id-Version: PostgreSQL JDBC Driver 8.2\nReport-Msgid-Bugs-To: \nPO-Revision-Date: 2006-06-23 17:25+0200\nLast-Translator: Giuseppe Sacco <eppesuig@debian.org>\nLanguage-Team: Italian <tp@lists.linux.it>\nLanguage: it\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n";
    t[2] = "{0} function doesn''t take any argument.";
    t[3] = "Il metodo ï¿½{0}ï¿½ non accetta argomenti.";
    t[4] = "Provided InputStream failed.";
    t[5] = "L''ï¿½InputStreamï¿½ fornito ï¿½ fallito.";
    t[14] = "Interval {0} not yet implemented";
    t[15] = "L''intervallo ï¿½{0}ï¿½ non ï¿½ stato ancora implementato.";
    t[20] = "Can''t infer the SQL type to use for an instance of {0}. Use setObject() with an explicit Types value to specify the type to use.";
    t[21] = "Non ï¿½ possibile identificare il tipo SQL da usare per l''istanza di tipo ï¿½{0}ï¿½. Usare ï¿½setObject()ï¿½ specificando esplicitamente il tipo da usare per questo valore.";
    t[22] = "Transaction isolation level {0} not supported.";
    t[23] = "Il livello di isolamento delle transazioni ï¿½{0}ï¿½ non ï¿½ supportato.";
    t[24] = "The server''s DateStyle parameter was changed to {0}. The JDBC driver requires DateStyle to begin with ISO for correct operation.";
    t[25] = "Il parametro del server ï¿½DateStyleï¿½ ï¿½ stato cambiato in {0}. Il driver JDBC richiede che ï¿½DateStyleï¿½ cominci con ï¿½ISOï¿½ per un corretto funzionamento.";
    t[28] = "Conversion of interval failed";
    t[29] = "Fallita la conversione di un ï¿½intervalï¿½.";
    t[30] = "Too many update results were returned.";
    t[31] = "Sono stati restituiti troppi aggiornamenti.";
    t[32] = "Unable to determine a value for MaxIndexKeys due to missing system catalog data.";
    t[33] = "Non ï¿½ possibile trovare il valore di ï¿½MaxIndexKeysï¿½ nel catalogo si sistema.";
    t[34] = "Cannot tell if path is open or closed: {0}.";
    t[35] = "Impossibile stabilire se il percorso ï¿½ aperto o chiuso: {0}.";
    t[38] = "Failed to create object for: {0}.";
    t[39] = "Fallita la creazione dell''oggetto per: {0}.";
    t[42] = "There are no rows in this ResultSet.";
    t[43] = "Non ci sono righe in questo ï¿½ResultSetï¿½.";
    t[44] = "Provided Reader failed.";
    t[45] = "Il ï¿½Readerï¿½ fornito ï¿½ fallito.";
    t[46] = "Conversion to type {0} failed: {1}.";
    t[47] = "Conversione al tipo {0} fallita: {1}.";
    t[50] = "Unknown ResultSet holdability setting: {0}.";
    t[51] = "Il parametro ï¿½holdabilityï¿½ per il ï¿½ResultSetï¿½ ï¿½ sconosciuto: {0}.";
    t[52] = "Expected an EOF from server, got: {0}";
    t[53] = "Ricevuto dal server ï¿½{0}ï¿½ mentre era atteso un EOF";
    t[58] = "Protocol error.  Session setup failed.";
    t[59] = "Errore di protocollo. Impostazione della sessione fallita.";
    t[60] = "The maximum field size must be a value greater than or equal to 0.";
    t[61] = "La dimensione massima del campo deve essere maggiore o eguale a 0.";
    t[62] = "{0} function takes three and only three arguments.";
    t[63] = "Il metodo ï¿½{0}ï¿½ accetta tre e solo tre argomenti.";
    t[68] = "Internal Position: {0}";
    t[69] = "Posizione interna: {0}";
    t[70] = "Can''t use query methods that take a query string on a PreparedStatement.";
    t[71] = "Non si possono utilizzare i metodi \"query\" che hanno come argomento una stringa nel caso di ï¿½PreparedStatementï¿½.";
    t[72] = "Bind message length {0} too long.  This can be caused by very large or incorrect length specifications on InputStream parameters.";
    t[73] = "Il messaggio di ï¿½bindï¿½ ï¿½ troppo lungo ({0}). Questo puï¿½ essere causato da una dimensione eccessiva o non corretta dei parametri dell''ï¿½InputStreamï¿½.";
    t[74] = "Premature end of input stream, expected {0} bytes, but only read {1}.";
    t[75] = "Il flusso di input ï¿½ stato interrotto, sono arrivati {1} byte al posto dei {0} attesi.";
    t[76] = "Unknown type {0}.";
    t[77] = "Tipo sconosciuto {0}.";
    t[82] = "The JVM claims not to support the {0} encoding.";
    t[83] = "La JVM sostiene di non supportare la codifica {0}.";
    t[84] = "Illegal UTF-8 sequence: {0} bytes used to encode a {1} byte value: {2}";
    t[85] = "Sequenza UTF-8 illegale: {0} byte utilizzati per codificare un valore di {1} byte: {2}";
    t[88] = "Internal Query: {0}";
    t[89] = "Query interna: {0}";
    t[90] = "suspend/resume not implemented";
    t[91] = "ï¿½suspendï¿½/ï¿½resumeï¿½ non implementato";
    t[94] = "Method {0} is not yet implemented.";
    t[95] = "Il metodo ï¿½{0}ï¿½ non ï¿½ stato ancora implementato.";
    t[102] = "DataSource has been closed.";
    t[103] = "Questo ï¿½DataSourceï¿½ ï¿½ stato chiuso.";
    t[104] = "An unexpected result was returned by a query.";
    t[105] = "Un risultato inaspettato ï¿½ stato ricevuto dalla query.";
    t[106] = "{0} function takes one and only one argument.";
    t[107] = "Il metodo ï¿½{0}ï¿½ accetta un ed un solo argomento.";
    t[110] = "ResultSet is not updateable.  The query that generated this result set must select only one table, and must select all primary keys from that table. See the JDBC 2.1 API Specification, section 5.6 for more details.";
    t[111] = "Il ï¿½ResultSetï¿½ non ï¿½ aggiornabile. La query che lo genera deve selezionare una sola tabella e deve selezionarne tutti i campi che ne compongono la chiave primaria. Si vedano le specifiche dell''API JDBC 2.1, sezione 5.6, per ulteriori dettagli.";
    t[112] = "Query timeout must be a value greater than or equals to 0.";
    t[113] = "Il timeout relativo alle query deve essere maggiore o eguale a 0.";
    t[118] = "The SSLSocketFactory class provided {0} could not be instantiated.";
    t[119] = "La classe ï¿½SSLSocketFactoryï¿½ specificata, ï¿½{0}ï¿½, non puï¿½ essere istanziata.";
    t[128] = "Can''t refresh the insert row.";
    t[129] = "Non ï¿½ possibile aggiornare la riga in inserimento.";
    t[130] = "Invalid character data was found.  This is most likely caused by stored data containing characters that are invalid for the character set the database was created in.  The most common example of this is storing 8bit data in a SQL_ASCII database.";
    t[131] = "Sono stati trovati caratteri non validi tra i dati. Molto probabilmente sono stati memorizzati dei caratteri che non sono validi per la codifica dei caratteri impostata alla creazione del database. Il caso piï¿½ diffuso ï¿½ quello nel quale si memorizzano caratteri a 8bit in un database con codifica SQL_ASCII.";
    t[132] = "Illegal UTF-8 sequence: final value is a surrogate value: {0}";
    t[133] = "Sequenza UTF-8 illegale: il valore ï¿½ finale ï¿½ un surrogato: {0}";
    t[136] = "Ran out of memory retrieving query results.";
    t[137] = "Fine memoria scaricando i risultati della query.";
    t[142] = "Error loading default settings from driverconfig.properties";
    t[143] = "Si ï¿½ verificato un errore caricando le impostazioni predefinite da ï¿½driverconfig.propertiesï¿½.";
    t[148] = "Server SQLState: {0}";
    t[149] = "SQLState del server: {0}";
    t[150] = "Currently positioned before the start of the ResultSet.  You cannot call deleteRow() here.";
    t[151] = "La posizione attuale ï¿½ precedente all''inizio del ResultSet. Non ï¿½ possibile invocare ï¿½deleteRow()ï¿½ qui.";
    t[154] = "A CallableStatement function was executed and the out parameter {0} was of type {1} however type {2} was registered.";
    t[155] = "ï¿½ stato eseguito un ï¿½CallableStatementï¿½ ma il parametro in uscita ï¿½{0}ï¿½ era di tipo ï¿½{1}ï¿½ al posto di ï¿½{2}ï¿½, che era stato dichiarato.";
    t[156] = "This statement does not declare an OUT parameter.  Use '{' ?= call ... '}' to declare one.";
    t[157] = "Questo statement non dichiara il parametro in uscita. Usare ï¿½{ ?= call ... }ï¿½ per farlo.";
    t[162] = "Bad value for type {0} : {1}";
    t[163] = "Il valore ï¿½{1}ï¿½ non ï¿½ adeguato al tipo ï¿½{0}ï¿½.";
    t[164] = "Statement has been closed.";
    t[165] = "Questo ï¿½Statementï¿½ ï¿½ stato chiuso.";
    t[168] = "Zero bytes may not occur in string parameters.";
    t[169] = "Byte con valore zero non possono essere contenuti nei parametri stringa.";
    t[170] = "Fetch size must be a value greater to or equal to 0.";
    t[171] = "La dimensione dell''area di ï¿½fetchï¿½ deve essere maggiore o eguale a 0.";
    t[174] = "Invalid stream length {0}.";
    t[175] = "La dimensione specificata, {0}, per lo ï¿½streamï¿½ non ï¿½ valida.";
    t[178] = "Hint: {0}";
    t[179] = "Suggerimento: {0}";
    t[182] = "The authentication type {0} is not supported. Check that you have configured the pg_hba.conf file to include the client''s IP address or subnet, and that it is using an authentication scheme supported by the driver.";
    t[183] = "L''autenticazione di tipo {0} non ï¿½ supportata. Verificare che nel file di configurazione pg_hba.conf sia presente l''indirizzo IP o la sottorete del client, e che lo schema di autenticazione utilizzato sia supportato dal driver.";
    t[188] = "Cannot establish a savepoint in auto-commit mode.";
    t[189] = "Non ï¿½ possibile impostare i punti di ripristino in modalitï¿½ ï¿½auto-commitï¿½.";
    t[192] = "Illegal UTF-8 sequence: final value is out of range: {0}";
    t[193] = "Sequenza UTF-8 illegale: il valore finale ï¿½ fuori dall''intervallo permesso: {0}";
    t[196] = "The connection attempt failed.";
    t[197] = "Il tentativo di connessione ï¿½ fallito.";
    t[198] = "Error during recover";
    t[199] = "Errore durante il ripristino";
    t[200] = "Illegal UTF-8 sequence: byte {0} of {1} byte sequence is not 10xxxxxx: {2}";
    t[201] = "Sequenza UTF-8 illegale: il byte {0} di una sequenza di {1} byte non ï¿½ 10xxxxxx: {2}";
    t[202] = "Returning autogenerated keys is not supported.";
    t[203] = "La restituzione di chiavi autogenerate non ï¿½ supportata.";
    t[212] = "Location: File: {0}, Routine: {1}, Line: {2}";
    t[213] = "Individuazione: file: \"{0}\", routine: {1}, linea: {2}";
    t[214] = "Interrupted while attempting to connect.";
    t[215] = "Si ï¿½ verificata una interruzione durante il tentativo di connessione.";
    t[218] = "Can''t use relative move methods while on the insert row.";
    t[219] = "Non ï¿½ possibile utilizzare gli spostamenti relativi durante l''inserimento di una riga.";
    t[226] = "LOB positioning offsets start at 1.";
    t[227] = "L''offset per la posizione dei LOB comincia da 1.";
    t[228] = "Conversion of money failed.";
    t[229] = "Fallita la conversione di un ï¿½moneyï¿½.";
    t[232] = "The column index is out of range: {0}, number of columns: {1}.";
    t[233] = "Indice di colonna, {0}, ï¿½ maggiore del numero di colonne {1}.";
    t[234] = "Illegal UTF-8 sequence: initial byte is {0}: {1}";
    t[235] = "Sequenza UTF-8 illegale: il byte iniziale ï¿½ {0}: {1}";
    t[240] = "Unknown Response Type {0}.";
    t[241] = "Risposta di tipo sconosciuto {0}.";
    t[242] = "No primary key found for table {0}.";
    t[243] = "Non ï¿½ stata trovata la chiave primaria della tabella ï¿½{0}ï¿½.";
    t[250] = "Unable to translate data into the desired encoding.";
    t[251] = "Impossibile tradurre i dati nella codifica richiesta.";
    t[252] = "Malformed function or procedure escape syntax at offset {0}.";
    t[253] = "Sequenza di escape definita erroneamente nella funzione o procedura all''offset {0}.";
    t[254] = "Unable to find name datatype in the system catalogs.";
    t[255] = "Non ï¿½ possibile trovare il datatype ï¿½nameï¿½ nel catalogo di sistema.";
    t[256] = "The array index is out of range: {0}, number of elements: {1}.";
    t[257] = "L''indice dell''array ï¿½ fuori intervallo: {0}, numero di elementi: {1}.";
    t[258] = "An I/O error occurred while sending to the backend.";
    t[259] = "Si ï¿½ verificato un errore di I/O nella spedizione di dati al server.";
    t[260] = "Fastpath call {0} - No result was returned and we expected an integer.";
    t[261] = "Chiamata Fastpath ï¿½{0}ï¿½: Nessun risultato restituito mentre ci si aspettava un intero.";
    t[262] = "xid must not be null";
    t[263] = "xid non puï¿½ essere NULL";
    t[264] = "Cannot update the ResultSet because it is either before the start or after the end of the results.";
    t[265] = "Non ï¿½ possibile aggiornare il ï¿½ResultSetï¿½ perchï¿½ la posizione attuale ï¿½ precedente all''inizio o successiva alla file dei risultati.";
    t[266] = "Detail: {0}";
    t[267] = "Dettaglio: {0}";
    t[270] = "Operation requires a scrollable ResultSet, but this ResultSet is FORWARD_ONLY.";
    t[271] = "L''operazione richiete un ï¿½ResultSetï¿½ scorribile mentre questo ï¿½ ï¿½FORWARD_ONLYï¿½.";
    t[274] = "ResultSet not positioned properly, perhaps you need to call next.";
    t[275] = "Il ï¿½ResultSetï¿½ non ï¿½ correttamente posizionato; forse ï¿½ necessario invocare ï¿½next()ï¿½.";
    t[276] = "This statement has been closed.";
    t[277] = "Questo statement ï¿½ stato chiuso.";
    t[280] = "Unable to load the class {0} responsible for the datatype {1}";
    t[281] = "Non ï¿½ possibile caricare la class ï¿½{0}ï¿½ per gestire il tipo ï¿½{1}ï¿½.";
    t[282] = "Expected command status BEGIN, got {0}.";
    t[283] = "Lo stato del comando avrebbe dovuto essere BEGIN, mentre invece ï¿½ {0}.";
    t[284] = "Cannot retrieve the id of a named savepoint.";
    t[285] = "Non ï¿½ possibile trovare l''id del punto di ripristino indicato.";
    t[298] = "A result was returned when none was expected.";
    t[299] = "ï¿½ stato restituito un valore nonostante non ne fosse atteso nessuno.";
    t[300] = "Maximum number of rows must be a value greater than or equal to 0.";
    t[301] = "Il numero massimo di righe deve essere maggiore o eguale a 0.";
    t[302] = "The server requested password-based authentication, but no password was provided.";
    t[303] = "Il server ha richiesto l''autenticazione con password, ma tale password non ï¿½ stata fornita.";
    t[306] = "{0} function takes two and only two arguments.";
    t[307] = "Il metodo ï¿½{0}ï¿½ accetta due e solo due argomenti.";
    t[312] = "The JVM claims not to support the encoding: {0}";
    t[313] = "La JVM sostiene di non supportare la codifica: {0}.";
    t[314] = "Unable to bind parameter values for statement.";
    t[315] = "Impossibile fare il ï¿½bindï¿½ dei valori passati come parametri per lo statement.";
    t[316] = "The column name {0} was not found in this ResultSet.";
    t[317] = "Colonna denominata ï¿½{0}ï¿½ non ï¿½ presente in questo ï¿½ResultSetï¿½.";
    t[318] = "Cannot reference a savepoint after it has been released.";
    t[319] = "Non ï¿½ possibile utilizzare un punto di ripristino successivamente al suo rilascio.";
    t[320] = "{0} function takes two or three arguments.";
    t[321] = "Il metodo ï¿½{0}ï¿½ accetta due o tre argomenti.";
    t[324] = "A CallableStatement was declared, but no call to registerOutParameter(1, <some type>) was made.";
    t[325] = "ï¿½ stato definito un ï¿½CallableStatementï¿½ ma non ï¿½ stato invocato il metodo ï¿½registerOutParameter(1, <tipo>)ï¿½.";
    t[326] = "The server does not support SSL.";
    t[327] = "Il server non supporta SSL.";
    t[334] = "Connection has been closed automatically because a new connection was opened for the same PooledConnection or the PooledConnection has been closed.";
    t[335] = "La ï¿½Connectionï¿½ ï¿½ stata chiusa automaticamente perchï¿½ una nuova l''ha sostituita nello stesso ï¿½PooledConnectionï¿½, oppure il ï¿½PooledConnectionï¿½ ï¿½ stato chiuso.";
    t[336] = "You must specify at least one column value to insert a row.";
    t[337] = "Per inserire un record si deve specificare almeno il valore di una colonna.";
    t[344] = "An error occurred while setting up the SSL connection.";
    t[345] = "Si ï¿½ verificato un errore impostando la connessione SSL.";
    t[350] = "Connection has been closed.";
    t[351] = "Questo ï¿½Connectionï¿½ ï¿½ stato chiuso.";
    t[352] = "Cannot retrieve the name of an unnamed savepoint.";
    t[353] = "Non ï¿½ possibile trovare il nome di un punto di ripristino anonimo.";
    t[354] = "Unsupported value for stringtype parameter: {0}";
    t[355] = "Il valore per il parametro di tipo string ï¿½{0}ï¿½ non ï¿½ supportato.";
    t[356] = "A CallableStatement was executed with nothing returned.";
    t[357] = "Un ï¿½CallableStatementï¿½ ï¿½ stato eseguito senza produrre alcun risultato. ";
    t[362] = "Position: {0}";
    t[363] = "Posizione: {0}";
    t[370] = "The array index is out of range: {0}";
    t[371] = "Indice di colonna fuori dall''intervallo ammissibile: {0}";
    t[372] = "Unexpected error writing large object to database.";
    t[373] = "Errore inatteso inviando un ï¿½large objectï¿½ al database.";
    t[384] = "Something unusual has occurred to cause the driver to fail. Please report this exception.";
    t[385] = "Qualcosa di insolito si ï¿½ verificato causando il fallimento del driver. Per favore riferire all''autore del driver questa eccezione.";
    t[390] = "Where: {0}";
    t[391] = "Dove: {0}";
    t[400] = "Not implemented: one-phase commit must be issued using the same connection that was used to start it";
    t[401] = "Non implementato: il commit \"one-phase\" deve essere invocato sulla stessa connessione che ha iniziato la transazione.";
    t[402] = "Connection is busy with another transaction";
    t[403] = "La connessione ï¿½ utilizzata da un''altra transazione";
    t[404] = "Unsupported Types value: {0}";
    t[405] = "Valore di tipo ï¿½{0}ï¿½ non supportato.";
    t[406] = "Cannot change transaction isolation level in the middle of a transaction.";
    t[407] = "Non ï¿½ possibile cambiare il livello di isolamento delle transazioni nel mezzo di una transazione.";
    t[408] = "This PooledConnection has already been closed.";
    t[409] = "Questo ï¿½PooledConnectionï¿½ ï¿½ stato chiuso.";
    t[418] = "Multiple ResultSets were returned by the query.";
    t[419] = "La query ha restituito ï¿½ResultSetï¿½ multipli.";
    t[424] = "Unknown Types value.";
    t[425] = "Valore di tipo sconosciuto.";
    t[426] = "Cannot convert an instance of {0} to type {1}";
    t[427] = "Non ï¿½ possibile convertire una istanza di ï¿½{0}ï¿½ nel tipo ï¿½{1}ï¿½";
    t[432] = "Invalid fetch direction constant: {0}.";
    t[433] = "Costante per la direzione dell''estrazione non valida: {0}.";
    t[434] = "PostgreSQL LOBs can only index to: {0}";
    t[435] = "Il massimo valore per l''indice dei LOB di PostgreSQL ï¿½ {0}. ";
    t[436] = "This ResultSet is closed.";
    t[437] = "Questo ï¿½ResultSetï¿½ ï¿½ chiuso.";
    t[438] = "ResultSets with concurrency CONCUR_READ_ONLY cannot be updated.";
    t[439] = "I ï¿½ResultSetï¿½ in modalitï¿½ CONCUR_READ_ONLY non possono essere aggiornati.";
    t[440] = "{0} function takes four and only four argument.";
    t[441] = "Il metodo ï¿½{0}ï¿½ accetta quattro e solo quattro argomenti.";
    t[442] = "The parameter index is out of range: {0}, number of parameters: {1}.";
    t[443] = "Il parametro indice ï¿½ fuori intervallo: {0}, numero di elementi: {1}.";
    t[454] = "Cannot cast an instance of {0} to type {1}";
    t[455] = "Non ï¿½ possibile fare il cast di una istanza di ï¿½{0}ï¿½ al tipo ï¿½{1}ï¿½.";
    t[456] = "Not on the insert row.";
    t[457] = "Non si ï¿½ in una nuova riga.";
    t[460] = "Cannot change transaction read-only property in the middle of a transaction.";
    t[461] = "Non ï¿½ possibile modificare la proprietï¿½ ï¿½read-onlyï¿½ delle transazioni nel mezzo di una transazione.";
    t[464] = "Large Objects may not be used in auto-commit mode.";
    t[465] = "Non ï¿½ possibile impostare i ï¿½Large Objectï¿½ in modalitï¿½ ï¿½auto-commitï¿½.";
    t[474] = "Connection attempt timed out.";
    t[475] = "Il tentativo di connessione ï¿½ scaduto.";
    t[478] = "Parameter of type {0} was registered, but call to get{1} (sqltype={2}) was made.";
    t[479] = "ï¿½ stato definito il parametro di tipo ï¿½{0}ï¿½, ma poi ï¿½ stato invocato il metodo ï¿½get{1}()ï¿½ (sqltype={2}).";
    t[480] = "The fastpath function {0} is unknown.";
    t[481] = "La funzione fastpath ï¿½{0}ï¿½ ï¿½ sconosciuta.";
    t[484] = "No results were returned by the query.";
    t[485] = "Nessun risultato ï¿½ stato restituito dalla query.";
    t[486] = "No value specified for parameter {0}.";
    t[487] = "Nessun valore specificato come parametro {0}.";
    t[488] = "A connection could not be made using the requested protocol {0}.";
    t[489] = "Non ï¿½ stato possibile attivare la connessione utilizzando il protocollo richiesto {0}.";
    t[492] = "Finalizing a Connection that was never closed:";
    t[493] = "Finalizzazione di una ï¿½Connectionï¿½ che non ï¿½ stata chiusa.";
    t[494] = "Cannot call deleteRow() when on the insert row.";
    t[495] = "Non ï¿½ possibile invocare ï¿½deleteRow()ï¿½ durante l''inserimento di una riga.";
    t[498] = "Cannot call updateRow() when on the insert row.";
    t[499] = "Non ï¿½ possibile invocare ï¿½updateRow()ï¿½ durante l''inserimento di una riga.";
    t[500] = "Currently positioned after the end of the ResultSet.  You cannot call deleteRow() here.";
    t[501] = "La posizione attuale ï¿½ successiva alla fine del ResultSet. Non ï¿½ possibile invocare ï¿½deleteRow()ï¿½ qui.";
    t[502] = "Unexpected command status: {0}.";
    t[503] = "Stato del comando non previsto: {0}.";
    t[504] = "Cannot call cancelRowUpdates() when on the insert row.";
    t[505] = "Non ï¿½ possibile invocare ï¿½cancelRowUpdates()ï¿½ durante l''inserimento di una riga.";
    table = t;
  }
  public java.lang.Object handleGetObject (java.lang.String msgid) throws java.util.MissingResourceException {
    int hash_val = msgid.hashCode() & 0x7fffffff;
    int idx = (hash_val % 253) << 1;
    {
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
    int incr = ((hash_val % 251) + 1) << 1;
    for (;;) {
      idx += incr;
      if (idx >= 506)
        idx -= 506;
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
  }
  public java.util.Enumeration getKeys () {
    return
      new java.util.Enumeration() {
        private int idx = 0;
        { while (idx < 506 && table[idx] == null) idx += 2; }
        public boolean hasMoreElements () {
          return (idx < 506);
        }
        public java.lang.Object nextElement () {
          java.lang.Object key = table[idx];
          do idx += 2; while (idx < 506 && table[idx] == null);
          return key;
        }
      };
  }
  public java.util.ResourceBundle getParent () {
    return parent;
  }
}
