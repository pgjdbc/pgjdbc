/* Automatically generated by GNU msgfmt.  Do not modify!  */
package org.postgresql.translation;
public class messages_it extends java.util.ResourceBundle {
  private static final java.lang.String[] table;
  static {
    java.lang.String[] t = new java.lang.String[1034];
    t[0] = "";
    t[1] = "Project-Id-Version: PostgreSQL JDBC Driver 8.2\nReport-Msgid-Bugs-To: \nPO-Revision-Date: 2018-07-25 08:37+0100\nLast-Translator: Federico Campoli <rotellaro@gmail.com>\nLanguage-Team: Italian <tp@lists.linux.it>\nLanguage: it\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\nX-Generator: Poedit 1.8.12\n";
    t[8] = "Bad value for type {0} : {1}";
    t[9] = "Il valore «{1}» non è adeguato al tipo «{0}».";
    t[16] = "Illegal UTF-8 sequence: final value is out of range: {0}";
    t[17] = "Sequenza UTF-8 illegale: il valore finale è fuori dall''intervallo permesso: {0}";
    t[18] = "Can''t refresh the insert row.";
    t[19] = "Non è possibile aggiornare la riga in inserimento.";
    t[20] = "Connection has been closed.";
    t[21] = "Questo «Connection» è stato chiuso.";
    t[24] = "attacl";
    t[25] = "attacl";
    t[28] = "Bind message length {0} too long.  This can be caused by very large or incorrect length specifications on InputStream parameters.";
    t[29] = "Il messaggio di «bind» è troppo lungo ({0}). Questo può essere causato da una dimensione eccessiva o non corretta dei parametri dell''«InputStream».";
    t[30] = "proargtypes";
    t[31] = "proargtypes";
    t[36] = "No hstore extension installed.";
    t[37] = "L'estensione hstore non é installata sul server.";
    t[38] = "Unable to load the class {0} responsible for the datatype {1}";
    t[39] = "Non è possibile caricare la class «{0}» per gestire il tipo «{1}».";
    t[42] = "Cannot change transaction read-only property in the middle of a transaction.";
    t[43] = "Non è possibile modificare la proprietà «read-only» delle transazioni nel mezzo di una transazione.";
    t[44] = "Internal Query: {0}";
    t[45] = "Query interna: {0}";
    t[48] = "CommandComplete expected COPY but got: ";
    t[49] = "Atteso «COPY» da «CommandComplete». Invece si é ricevuto: ";
    t[52] = "Finalizing a Connection that was never closed:";
    t[53] = "Finalizzazione di una «Connection» che non è stata chiusa.";
    t[54] = "Statement has been closed.";
    t[55] = "Questo «Statement» è stato chiuso.";
    t[56] = "Cannot establish a savepoint in auto-commit mode.";
    t[57] = "Non è possibile impostare i punti di ripristino in modalità «auto-commit».";
    t[62] = "Could not open SSL certificate file {0}.";
    t[63] = "Impossibile accedere al file di certificato SSL {0}.";
    t[66] = "Unable to convert DOMResult SQLXML data to a string.";
    t[67] = "Impossibile convertire i dati «DOMResult SQLXML» in stringa.";
    t[70] = "Cannot tell if path is open or closed: {0}.";
    t[71] = "Impossibile stabilire se il percorso è aperto o chiuso: {0}.";
    t[76] = "Malformed function or procedure escape syntax at offset {0}.";
    t[77] = "Sequenza di escape definita erroneamente nella funzione o procedura all''offset {0}.";
    t[88] = "Illegal UTF-8 sequence: final value is a surrogate value: {0}";
    t[89] = "Sequenza UTF-8 illegale: il valore è finale è un surrogato: {0}";
    t[92] = "The JVM claims not to support the encoding: {0}";
    t[93] = "La JVM sostiene di non supportare la codifica: {0}.";
    t[98] = "Could not find a java cryptographic algorithm: X.509 CertificateFactory not available.";
    t[99] = "Impossibile trovare un algoritmo crittografico java: «X.509 CertificateFactory» non disponibile.";
    t[100] = "The column index is out of range: {0}, number of columns: {1}.";
    t[101] = "Indice di colonna, {0}, è maggiore del numero di colonne {1}.";
    t[102] = "Invalid server SCRAM signature";
    t[103] = "La firma SCRAM del server é invalida";
    t[104] = "The server requested password-based authentication, but no password was provided.";
    t[105] = "Il server ha richiesto l''autenticazione con password, ma tale password non è stata fornita.";
    t[120] = "wasNull cannot be call before fetching a result.";
    t[121] = "«wasNull» non può essere eseguito prima della lettura di un «result».";
    t[122] = "Invalid protocol state requested. Attempted transaction interleaving is not supported. xid={0}, currentXid={1}, state={2}, flags={3}";
    t[123] = "Stato del protocollo richiesto non valido. Il tentativo di interlacciamento transazioni non é supportato. xid={0}, currentXid={1}, state={2}, flags={3}";
    t[126] = "Could not initialize SSL context.";
    t[127] = "Impossibile inizializzare il contesto SSL.";
    t[132] = "{0} function takes four and only four argument.";
    t[133] = "Il metodo «{0}» accetta quattro e solo quattro argomenti.";
    t[140] = "One-phase commit called for xid {0} but connection was prepared with xid {1}";
    t[141] = "«One-phase commit»  eseguito per xid {0}, tuttavia la connessione era stata già preparata con lo xid {1}";
    t[142] = "Unable to create StAXResult for SQLXML";
    t[143] = "Impossibile creare «StAXResult» per «SQLXML»";
    t[146] = "Protocol error.  Session setup failed.";
    t[147] = "Errore di protocollo. Impostazione della sessione fallita.";
    t[148] = "Unknown Types value.";
    t[149] = "Valore di tipo sconosciuto.";
    t[152] = "Cannot truncate LOB to a negative length.";
    t[153] = "Non é possibile troncare i LOB ad una dimensione negativa.";
    t[154] = "Object is too large to send over the protocol.";
    t[155] = "Le dimensioni dell'oggetto sono troppo grandi per la trasmissione attraverso il protocollo.";
    t[160] = "Failed to initialize LargeObject API";
    t[161] = "Inizializzazione di LargeObject API fallita.";
    t[162] = "Your security policy has prevented the connection from being attempted.  You probably need to grant the connect java.net.SocketPermission to the database server host and port that you wish to connect to.";
    t[163] = "Le impostazioni di sicurezza hanno impedito il tentativo di connessione. Probabilmente è necessario configurare «grant» affinché «java.net.SocketPermission» abbia il con il permesso di connettersi all'host del database server a cui ci si vuole connettere.";
    t[164] = "Enter SSL password: ";
    t[165] = "Inserire la password SSL: ";
    t[168] = "The driver currently does not support COPY operations.";
    t[169] = "Il driver non supporta al momento l''operazione «COPY».";
    t[170] = "Validating connection.";
    t[171] = "Verifica connessione.";
    t[174] = "Requested CopyOut but got {0}";
    t[175] = "Era richiesto «CopyOut» ma si é ottenuto {0}";
    t[178] = "Current connection does not have an associated xid. prepare xid={0}";
    t[179] = "Alla connessione corrente non é associato nessun xid. «prepare xid»={0}";
    t[180] = "Provided Reader failed.";
    t[181] = "Il «Reader» fornito è fallito.";
    t[182] = "LOB positioning offsets start at 1.";
    t[183] = "L''offset per la posizione dei LOB comincia da 1.";
    t[188] = "Unable to find name datatype in the system catalogs.";
    t[189] = "Non è possibile trovare il datatype «name» nel catalogo di sistema.";
    t[194] = "{0} function takes one and only one argument.";
    t[195] = "Il metodo «{0}» accetta un ed un solo argomento.";
    t[198] = "No SCRAM mechanism(s) advertised by the server";
    t[199] = "Il server non dispone di funzionalità SCRAM";
    t[210] = "This PooledConnection has already been closed.";
    t[211] = "Questo «PooledConnection» è stato chiuso.";
    t[214] = "{0} parameter value must be an integer but was: {1}";
    t[215] = "Il valore del parametro {0} deve essere un numero intero, invece il suo valore é {1}";
    t[216] = "Unexpected command status: {0}.";
    t[217] = "Stato del comando non previsto: {0}.";
    t[218] = "Location: File: {0}, Routine: {1}, Line: {2}";
    t[219] = "Individuazione: file: \"{0}\", routine: {1}, linea: {2}";
    t[222] = "This statement does not declare an OUT parameter.  Use '{' ?= call ... '}' to declare one.";
    t[223] = "Questo statement non dichiara il parametro in uscita. Usare «{ ?= call ... }» per farlo.";
    t[226] = "Connection is busy with another transaction";
    t[227] = "La connessione è utilizzata da un''altra transazione";
    t[236] = "Interrupted while attempting to connect.";
    t[237] = "Si è verificata una interruzione durante il tentativo di connessione.";
    t[238] = "Unexpected packet type during copy: {0}";
    t[239] = "Ricevuto «packet type» inaspettato durante operazione «copy»: {0}";
    t[240] = "There are no rows in this ResultSet.";
    t[241] = "Non ci sono righe in questo «ResultSet».";
    t[246] = "Maximum number of rows must be a value grater than or equal to 0.";
    t[247] = "Il numero massimo di righe deve essere maggiore o eguale a 0.";
    t[248] = "Unable to decode xml data.";
    t[249] = "Impossibile decodificare i dati xml.";
    t[250] = "Copying from database failed: {0}";
    t[251] = "Copia dal database fallita: {0}";
    t[252] = "Provided InputStream failed.";
    t[253] = "L''«InputStream» fornito è fallito.";
    t[260] = "SCRAM authentication failed, server returned error: {0}";
    t[261] = "Autenticazione SCRAM fallita, il server ha ritornato l''errore: {0}";
    t[264] = "Multiple ResultSets were returned by the query.";
    t[265] = "La query ha restituito «ResultSet» multipli.";
    t[266] = "Large Objects may not be used in auto-commit mode.";
    t[267] = "Non è possibile impostare i «Large Object» in modalità «auto-commit».";
    t[270] = "SSL error: {0}";
    t[271] = "Errore SSL: {0}";
    t[272] = "The sslfactoryarg property may not be empty.";
    t[273] = "La proprietà sslfactoryarg non deve essere vuota.";
    t[276] = "Unknown XML Source class: {0}";
    t[277] = "Classe sorgente XML sconosciuta: {0}";
    t[284] = "One-phase commit with unknown xid. commit xid={0}, currentXid={1}";
    t[285] = "«One-phase commit» con xid sconosciuto. commit xid={0}, currentXid={1}";
    t[290] = "Could not find a java cryptographic algorithm: {0}.";
    t[291] = "Impossibile determinare l''algoritmo crittografico java: {0}";
    t[292] = "You must specify at least one column value to insert a row.";
    t[293] = "Per inserire un record si deve specificare almeno il valore di una colonna.";
    t[294] = "Too many update results were returned.";
    t[295] = "Sono stati restituiti troppi aggiornamenti.";
    t[296] = "Results cannot be retrieved from a CallableStatement before it is executed.";
    t[297] = "I «result» non possono essere letti da un «CallableStatement» prima che esso sia stato eseguito.";
    t[300] = "oid type {0} not known and not a number";
    t[301] = "Lo oid {0} é di tipo sconosciuto oppure non é numerico";
    t[304] = "Invalid stream length {0}.";
    t[305] = "La dimensione specificata, {0}, per lo «stream» non è valida.";
    t[308] = "No primary key found for table {0}.";
    t[309] = "Non è stata trovata la chiave primaria della tabella «{0}».";
    t[320] = "Could not read SSL root certificate file {0}.";
    t[321] = "Impossibile leggere il file di certificato root SSL {0}.";
    t[322] = "Illegal UTF-8 sequence: initial byte is {0}: {1}";
    t[323] = "Sequenza UTF-8 illegale: il byte iniziale è {0}: {1}";
    t[326] = "Cannot convert the column of type {0} to requested type {1}.";
    t[327] = "Non è possibile convertire la colonna di tipo «{0}» nel tipo «{1}»";
    t[330] = "{0} function takes three and only three arguments.";
    t[331] = "Il metodo «{0}» accetta tre e solo tre argomenti.";
    t[332] = "This SQLXML object has already been initialized, so you cannot manipulate it further.";
    t[333] = "Non è possibile manipolare l'oggetto «SQLXML»  dopo che è stato inizializzato.";
    t[338] = "rolname";
    t[339] = "rolname";
    t[348] = "The server does not support SSL.";
    t[349] = "Il server non supporta SSL.";
    t[354] = "Query timeout must be a value greater than or equals to 0.";
    t[355] = "Il timeout relativo alle query deve essere maggiore o eguale a 0.";
    t[360] = "Got CopyOutResponse from server during an active {0}";
    t[361] = "Ricevuto «CopyOutResponse» dal server durante un {0} attivo";
    t[362] = "Tried to cancel an inactive copy operation";
    t[363] = "Si é tentato di cancellare una operazione di «copy» inattiva";
    t[364] = "The SSLSocketFactory class provided {0} could not be instantiated.";
    t[365] = "La classe «SSLSocketFactory» specificata, «{0}», non può essere istanziata.";
    t[368] = "The array index is out of range: {0}, number of elements: {1}.";
    t[369] = "L''indice dell''array è fuori intervallo: {0}, numero di elementi: {1}.";
    t[374] = "Cannot write to copy a byte of value {0}";
    t[375] = "Impossible scrivere in «copy» un byte il cui valore è {0}";
    t[378] = "Internal Position: {0}";
    t[379] = "Posizione interna: {0}";
    t[388] = "Unexpected packet type during replication: {0}";
    t[389] = "Ricevuto «packet type» inaspettato durante replica: {0}";
    t[390] = "Requested CopyDual but got {0}";
    t[391] = "Era richiesto «CopyDual» ma si é ottenuto {0}";
    t[402] = "Conversion to type {0} failed: {1}.";
    t[403] = "Conversione al tipo {0} fallita: {1}.";
    t[404] = "typtype";
    t[405] = "typtype";
    t[406] = "Could not read password for SSL key file by callbackhandler {0}.";
    t[407] = "Impossibile leggere la password del file di chiave SSL con il «callbackhandler» {0}.";
    t[420] = "Could not read password for SSL key file, console is not available.";
    t[421] = "Impossibile leggere la password del file di chiave SSL, console non disponibile.";
    t[422] = "Returning autogenerated keys is not supported.";
    t[423] = "La restituzione di chiavi autogenerate non è supportata.";
    t[424] = "Received CommandComplete ''{0}'' without an active copy operation";
    t[425] = "É stato ricevuto un «CommandComplete« ''{0}'' senza un'operazione «copy» attiva";
    t[426] = "Operation requires a scrollable ResultSet, but this ResultSet is FORWARD_ONLY.";
    t[427] = "L''operazione richiete un «ResultSet» scorribile mentre questo è «FORWARD_ONLY».";
    t[430] = "{0} function takes two or three arguments.";
    t[431] = "Il metodo «{0}» accetta due o tre argomenti.";
    t[434] = "Could not find a server with specified targetServerType: {0}";
    t[435] = "Non riesco a trovare un server con il «targetServerType» specificato: {0}";
    t[438] = "The system property containing the server's SSL certificate must not be empty.";
    t[439] = "La variabile di sistema che contiene il certificato SSL del server non può essere vuota.";
    t[446] = "The authentication type {0} is not supported. Check that you have configured the pg_hba.conf file to include the client''s IP address or subnet, and that it is using an authentication scheme supported by the driver.";
    t[447] = "L''autenticazione di tipo {0} non è supportata. Verificare che nel file di configurazione pg_hba.conf sia presente l''indirizzo IP o la sottorete del client, e che lo schema di autenticazione utilizzato sia supportato dal driver.";
    t[448] = "The maximum field size must be a value greater than or equal to 0.";
    t[449] = "La dimensione massima del campo deve essere maggiore o eguale a 0.";
    t[450] = "Could not read SSL key file {0}.";
    t[451] = "Impossibile leggere il file di chiave SSL {0}.";
    t[454] = "Cannot call updateRow() when on the insert row.";
    t[455] = "Non è possibile invocare «updateRow()» durante l''inserimento di una riga.";
    t[456] = "Database connection failed when starting copy";
    t[457] = "Connessione al database fallita durante l'avvio della copy";
    t[460] = "The connection attempt failed.";
    t[461] = "Il tentativo di connessione è fallito.";
    t[464] = "The sslfactoryarg property must start with the prefix file:, classpath:, env:, sys:, or -----BEGIN CERTIFICATE-----.";
    t[465] = "La proprietà sslfactoryarg deve iniziare con il uno dei seguenti prefissi, file:, classpath:, env:, sys:, oppure -----BEGIN CERTIFICATE-----.";
    t[468] = "Read from copy failed.";
    t[469] = "Lettura da «copy» fallita.";
    t[470] = "Cannot commit when autoCommit is enabled.";
    t[471] = "Il «commit» esplicito non é possibile quando «autoCommit» é abilitato.";
    t[472] = "Something unusual has occurred to cause the driver to fail. Please report this exception.";
    t[473] = "Qualcosa di insolito si è verificato causando il fallimento del driver. Per favore riferire all''autore del driver questa eccezione.";
    t[478] = "Not on the insert row.";
    t[479] = "Non si è in una nuova riga.";
    t[482] = "No X509TrustManager found";
    t[483] = "Impossibile trovare «X509TrustManager»";
    t[488] = "SCRAM authentication is not supported by this driver. You need JDK >= 8 and pgjdbc >= 42.2.0 (not \".jre\" versions)";
    t[489] = "L'autenticazione SCRAM non é supportata da questo driver. É necessario usare un JDK >= 8 e pgjdbc >= 42.2.0 (versione non \".jre\")";
    t[494] = "Cannot call deleteRow() when on the insert row.";
    t[495] = "Non è possibile invocare «deleteRow()» durante l''inserimento di una riga.";
    t[496] = "Failed to create object for: {0}.";
    t[497] = "Fallita la creazione dell''oggetto per: {0}.";
    t[498] = "An error occurred while setting up the SSL connection.";
    t[499] = "Si è verificato un errore impostando la connessione SSL.";
    t[500] = "An I/O error occurred while sending to the backend.";
    t[501] = "Si è verificato un errore di I/O nella spedizione di dati al server.";
    t[510] = "Database connection failed when writing to copy";
    t[511] = "La connessione al database é fallita durante la scrittura in «copy»";
    t[512] = "Unknown ResultSet holdability setting: {0}.";
    t[513] = "Il parametro «holdability» per il «ResultSet» è sconosciuto: {0}.";
    t[520] = "relacl";
    t[521] = "relacl";
    t[522] = "suspend/resume not implemented";
    t[523] = "«suspend»/«resume» non implementato";
    t[524] = "Fastpath call {0} - No result was returned and we expected an integer.";
    t[525] = "Chiamata Fastpath «{0}»: Nessun risultato restituito mentre ci si aspettava un intero.";
    t[526] = "Unexpected error writing large object to database.";
    t[527] = "Errore inatteso inviando un «large object» al database.";
    t[528] = "Cannot retrieve the name of an unnamed savepoint.";
    t[529] = "Non è possibile trovare il nome di un punto di ripristino anonimo.";
    t[530] = "Requested CopyIn but got {0}";
    t[531] = "Era richiesto «CopyIn» ma si é ottenuto {0}";
    t[534] = "Unable to bind parameter values for statement.";
    t[535] = "Impossibile fare il «bind» dei valori passati come parametri per lo statement.";
    t[538] = "ResultSet not positioned properly, perhaps you need to call next.";
    t[539] = "Il «ResultSet» non è correttamente posizionato; forse è necessario invocare «next()».";
    t[542] = "Detail: {0}";
    t[543] = "Dettaglio: {0}";
    t[544] = "Unable to create SAXResult for SQLXML.";
    t[545] = "Impossibile creare «StAXResult» per «SQLXML».";
    t[546] = "Expected command status BEGIN, got {0}.";
    t[547] = "Lo stato del comando avrebbe dovuto essere BEGIN, mentre invece è {0}.";
    t[550] = "ResultSet is not updateable.  The query that generated this result set must select only one table, and must select all primary keys from that table. See the JDBC 2.1 API Specification, section 5.6 for more details.";
    t[551] = "Il «ResultSet» non è aggiornabile. La query che lo genera deve selezionare una sola tabella e deve selezionarne tutti i campi che ne compongono la chiave primaria. Si vedano le specifiche dell''API JDBC 2.1, sezione 5.6, per ulteriori dettagli.";
    t[556] = "Tried to break lock on database connection";
    t[557] = "Si é tentato di rimuovere il lock sulla connessione al database";
    t[560] = "The hostname {0} could not be verified by hostnameverifier {1}.";
    t[561] = "L''hostnameverifier {1} non é in grado di verificare l''hostname {0}.";
    t[564] = "Interval {0} not yet implemented";
    t[565] = "L''intervallo «{0}» non è stato ancora implementato.";
    t[566] = "A CallableStatement was declared, but no call to registerOutParameter(1, <some type>) was made.";
    t[567] = "È stato definito un «CallableStatement» ma non è stato invocato il metodo «registerOutParameter(1, <tipo>)».";
    t[568] = "Cannot retrieve the id of a named savepoint.";
    t[569] = "Non è possibile trovare l''id del punto di ripristino indicato.";
    t[570] = "Can''t use relative move methods while on the insert row.";
    t[571] = "Non è possibile utilizzare gli spostamenti relativi durante l''inserimento di una riga.";
    t[572] = "Hint: {0}";
    t[573] = "Suggerimento: {0}";
    t[576] = "conversion to {0} from {1} not supported";
    t[577] = "conversione da «{1}» a «{0}» non supportata.";
    t[578] = "Method {0} is not yet implemented.";
    t[579] = "Il metodo «{0}» non è stato ancora implementato.";
    t[580] = "Truncation of large objects is only implemented in 8.3 and later servers.";
    t[581] = "La truncate dei large object é implementata soltanto per i server di versione 8.3 e successive.";
    t[584] = " (pgjdbc: autodetected server-encoding to be {0}, if the message is not readable, please check database logs and/or host, port, dbname, user, password, pg_hba.conf)";
    t[585] = "(pgjdbc:  l''encoding del server rilevato automaticamente é {0}. Se il messaggio non é leggibile verificare i log del database, i parametri host, port, dbname, user, password oppure il file pg_hba.conf )";
    t[588] = "An unexpected result was returned by a query.";
    t[589] = "Un risultato inaspettato è stato ricevuto dalla query.";
    t[596] = "Cannot convert an instance of {0} to type {1}";
    t[597] = "Non è possibile convertire una istanza di «{0}» nel tipo «{1}»";
    t[602] = "Unable to translate data into the desired encoding.";
    t[603] = "Impossibile tradurre i dati nella codifica richiesta.";
    t[608] = "Could not open SSL root certificate file {0}.";
    t[609] = "Impossibile aprire il file di certificato root SSL {0}.";
    t[610] = "Database connection failed when reading from copy";
    t[611] = "La connessione al database é fallita durante la lettura da «copy»";
    t[626] = "The array index is out of range: {0}";
    t[627] = "Indice di colonna fuori dall''intervallo ammissibile: {0}";
    t[628] = "No results were returned by the query.";
    t[629] = "Nessun risultato è stato restituito dalla query.";
    t[630] = "Currently positioned before the start of the ResultSet.  You cannot call deleteRow() here.";
    t[631] = "La posizione attuale è precedente all''inizio del ResultSet. Non è possibile invocare «deleteRow()» qui.";
    t[644] = "Position: {0}";
    t[645] = "Posizione: {0}";
    t[654] = "Parameter of type {0} was registered, but call to get{1} (sqltype={2}) was made.";
    t[655] = "È stato definito il parametro di tipo «{0}», ma poi è stato invocato il metodo «get{1}()» (sqltype={2}).";
    t[668] = "CopyIn copy direction can't receive data";
    t[669] = "La direzione di copia «CopyIn»  non può ricevere dati";
    t[670] = "Error loading default settings from driverconfig.properties";
    t[671] = "Si è verificato un errore caricando le impostazioni predefinite da «driverconfig.properties».";
    t[674] = "A CallableStatement function was executed and the out parameter {0} was of type {1} however type {2} was registered.";
    t[675] = "È stato eseguito un «CallableStatement» ma il parametro in uscita «{0}» era di tipo «{1}» al posto di «{2}», che era stato dichiarato.";
    t[678] = "Error during recover";
    t[679] = "Errore durante il ripristino";
    t[680] = "Cannot call cancelRowUpdates() when on the insert row.";
    t[681] = "Non è possibile invocare «cancelRowUpdates()» durante l''inserimento di una riga.";
    t[682] = "This connection has been closed.";
    t[683] = "Questa connessione é stata chiusa.";
    t[690] = "Unable to find server array type for provided name {0}.";
    t[691] = "Il tipo array {0} non é presente sul server.";
    t[694] = "A result was returned when none was expected.";
    t[695] = "È stato restituito un valore nonostante non ne fosse atteso nessuno.";
    t[696] = "Invalid fetch direction constant: {0}.";
    t[697] = "Costante per la direzione dell''estrazione non valida: {0}.";
    t[698] = "The environment variable containing the server's SSL certificate must not be empty.";
    t[699] = "La variabile d''ambiente che contiene il certificato SSL del server non può essere vuota.";
    t[710] = "Tried to end inactive copy";
    t[711] = "Si é tentato di terminare una «copy» inattiva";
    t[718] = "Properties for the driver contains a non-string value for the key ";
    t[719] = "La proprietà del driver contiene un valore non stringa per la chiave corrispondente";
    t[720] = "Where: {0}";
    t[721] = "Dove: {0}";
    t[724] = "No IOException expected from StringBuffer or StringBuilder";
    t[725] = "Errore «IOException» inaspettato generato dalla classe «StringBuffer» o «StringBuilder»";
    t[728] = "Tried to obtain lock while already holding it";
    t[729] = "Si é tentato di ottenere un lock ma era già stato ottenuto";
    t[730] = "Can''t use query methods that take a query string on a PreparedStatement.";
    t[731] = "Non si possono utilizzare i metodi \"query\" che hanno come argomento una stringa nel caso di «PreparedStatement».";
    t[744] = "Could not decrypt SSL key file {0}.";
    t[745] = "Impossibile decriptare il file di chiave SSL {0}.";
    t[746] = "This statement has been closed.";
    t[747] = "Questo statement è stato chiuso.";
    t[750] = "Conversion of money failed.";
    t[751] = "Fallita la conversione di un «money».";
    t[752] = "A CallableStatement was executed with nothing returned.";
    t[753] = "Un «CallableStatement» è stato eseguito senza produrre alcun risultato. ";
    t[762] = "DataSource has been closed.";
    t[763] = "Questo «DataSource» è stato chiuso.";
    t[764] = "The fastpath function {0} is unknown.";
    t[765] = "La funzione fastpath «{0}» è sconosciuta.";
    t[766] = "free() was called on this LOB previously";
    t[767] = "«free()» é già stata eseguita su questo LOB in precedenza";
    t[772] = "Illegal UTF-8 sequence: byte {0} of {1} byte sequence is not 10xxxxxx: {2}";
    t[773] = "Sequenza UTF-8 illegale: il byte {0} di una sequenza di {1} byte non è 10xxxxxx: {2}";
    t[780] = "Cannot change transaction isolation level in the middle of a transaction.";
    t[781] = "Non è possibile cambiare il livello di isolamento delle transazioni nel mezzo di una transazione.";
    t[786] = "This SQLXML object has not been initialized, so you cannot retrieve data from it.";
    t[787] = "Impossibile leggere i dati da un oggetto «SQLXML» non inizializzato.";
    t[792] = "Loading the SSL root certificate {0} into a TrustManager failed.";
    t[793] = "Il caricamento del certificato SSL root {0}in «TrustManager» é fallito.";
    t[794] = "Unable to set network timeout.";
    t[795] = "Impossibile impostare il timeout di rete.";
    t[796] = "Ran out of memory retrieving query results.";
    t[797] = "Fine memoria scaricando i risultati della query.";
    t[798] = "No function outputs were registered.";
    t[799] = "Non é stata registrata nessuna funzione di output.";
    t[802] = "Tried to read from inactive copy";
    t[803] = "Tentativo di lettura da «copy» inattiva";
    t[806] = "Not implemented: one-phase commit must be issued using the same connection that was used to start it";
    t[807] = "Non implementato: il commit \"one-phase\" deve essere invocato sulla stessa connessione che ha iniziato la transazione.";
    t[808] = "Invalid or unsupported by client SCRAM mechanisms";
    t[809] = "Funzionalità SCRAM del client invalida o non supportata";
    t[810] = "Illegal UTF-8 sequence: {0} bytes used to encode a {1} byte value: {2}";
    t[811] = "Sequenza UTF-8 illegale: {0} byte utilizzati per codificare un valore di {1} byte: {2}";
    t[816] = "Unsupported value for stringtype parameter: {0}";
    t[817] = "Il valore per il parametro di tipo string «{0}» non è supportato.";
    t[820] = "{0} function takes two and only two arguments.";
    t[821] = "Il metodo «{0}» accetta due e solo due argomenti.";
    t[822] = "Unable to get network timeout.";
    t[823] = "Impossibile leggere il timeout di rete.";
    t[826] = "Failed to convert binary xml data to encoding: {0}.";
    t[827] = "La conversione di dati binari xml ad encoding {0} é fallita.";
    t[836] = "Cannot cast to boolean: \"{0}\"";
    t[837] = "Non é possibile convertire in booleano: \"{0}\"";
    t[840] = "Cannot update the ResultSet because it is either before the start or after the end of the results.";
    t[841] = "Non è possibile aggiornare il «ResultSet» perché la posizione attuale è precedente all''inizio o successiva alla file dei risultati.";
    t[844] = "oid";
    t[845] = "oid";
    t[848] = "Cannot reference a savepoint after it has been released.";
    t[849] = "Non è possibile utilizzare un punto di ripristino successivamente al suo rilascio.";
    t[852] = "Fetch size must be a value greater to or equal to 0.";
    t[853] = "La dimensione dell''area di «fetch» deve essere maggiore o eguale a 0.";
    t[856] = "Unable to determine a value for MaxIndexKeys due to missing system catalog data.";
    t[857] = "Non è possibile trovare il valore di «MaxIndexKeys» nel catalogo si sistema.";
    t[858] = "Unknown type {0}.";
    t[859] = "Tipo sconosciuto {0}.";
    t[862] = "Got CopyInResponse from server during an active {0}";
    t[863] = "Ricevuto «CopyInResponse» dal server durante un {0} attivo";
    t[874] = "Database connection failed when ending copy";
    t[875] = "La connessione al database é fallita durante la cancellazione di «copy»";
    t[878] = "ResultSets with concurrency CONCUR_READ_ONLY cannot be updated.";
    t[879] = "I «ResultSet» in modalità CONCUR_READ_ONLY non possono essere aggiornati.";
    t[880] = "The JVM claims not to support the {0} encoding.";
    t[881] = "La JVM sostiene di non supportare la codifica {0}.";
    t[882] = "{0} function doesn''t take any argument.";
    t[883] = "Il metodo «{0}» non accetta argomenti.";
    t[886] = "Got CopyBothResponse from server during an active {0}";
    t[887] = "Ricevuto «CopyBothResponse» dal server durante un {0} attivo";
    t[890] = "This ResultSet is closed.";
    t[891] = "Questo «ResultSet» è chiuso.";
    t[894] = "Invalid UUID data.";
    t[895] = "Dati UUID non validi.";
    t[896] = "The server''s DateStyle parameter was changed to {0}. The JDBC driver requires DateStyle to begin with ISO for correct operation.";
    t[897] = "Il parametro del server «DateStyle» è stato cambiato in {0}. Il driver JDBC richiede che «DateStyle» cominci con «ISO» per un corretto funzionamento.";
    t[898] = "Custom type maps are not supported.";
    t[899] = "Le «type map» customizzate non sono supportate.";
    t[900] = "xid must not be null";
    t[901] = "xid non può essere NULL";
    t[902] = "Database connection failed when canceling copy operation";
    t[903] = "Connessione al database fallita durante la cancellazione dell'operazione di «copy»";
    t[912] = "Loading the SSL certificate {0} into a KeyManager failed.";
    t[913] = "Impossibile caricare il certificato SSL {0} nel «KeyManager».";
    t[914] = "proname";
    t[915] = "proname";
    t[916] = "Got {0} error responses to single copy cancel request";
    t[917] = "Ricevute {0} risposte da una singola richiesta di cancellazione «copy»";
    t[918] = "Server SQLState: {0}";
    t[919] = "SQLState del server: {0}";
    t[924] = "Failed to setup DataSource.";
    t[925] = "Configurazione «DataSource» fallita.";
    t[928] = "Can''t infer the SQL type to use for an instance of {0}. Use setObject() with an explicit Types value to specify the type to use.";
    t[929] = "Non è possibile identificare il tipo SQL da usare per l''istanza di tipo «{0}». Usare «setObject()» specificando esplicitamente il tipo da usare per questo valore.";
    t[932] = "Premature end of input stream, expected {0} bytes, but only read {1}.";
    t[933] = "Il flusso di input è stato interrotto, sono arrivati {1} byte al posto dei {0} attesi.";
    t[934] = "adsrc";
    t[935] = "adsrc";
    t[938] = "Zero bytes may not occur in string parameters.";
    t[939] = "Byte con valore zero non possono essere contenuti nei parametri stringa.";
    t[940] = "Tried to write to an inactive copy operation";
    t[941] = "C'é stato un tentativo di scrittura su di una operazione «copy» inattiva";
    t[942] = "Cannot rollback when autoCommit is enabled.";
    t[943] = "Il «commit» non é possibile quando «autoCommit» é abilitato.";
    t[944] = "attidentity";
    t[945] = "attidentity";
    t[948] = "Preparing already prepared transaction, the prepared xid {0}, prepare xid={1}";
    t[949] = "La «Prepared transaction» é già stata preparata, lo xid della transazione preparata é {0}, lo xid della transazione che si é tentato di preparare é {1}";
    t[950] = "Connection has been closed automatically because a new connection was opened for the same PooledConnection or the PooledConnection has been closed.";
    t[951] = "La «Connection» è stata chiusa automaticamente perché una nuova l''ha sostituita nello stesso «PooledConnection», oppure il «PooledConnection» è stato chiuso.";
    t[952] = "Got CopyData without an active copy operation";
    t[953] = "Ricevuto «CopyData» senza un'operazione «copy» attiva";
    t[954] = "Transaction control methods setAutoCommit(true), commit, rollback and setSavePoint not allowed while an XA transaction is active.";
    t[955] = "Con una transazione XA attiva non sono permessi i seguenti metodi di controllo transazione: «setAutoCommit(true)», «commit», «rollback» e «setSavePoint».";
    t[958] = "PostgreSQL LOBs can only index to: {0}";
    t[959] = "Il massimo valore per l''indice dei LOB di PostgreSQL è {0}. ";
    t[960] = "GSS Authentication failed";
    t[961] = "Autenticazione «GSS» fallita";
    t[966] = "Cannot cast an instance of {0} to type {1}";
    t[967] = "Non è possibile fare il cast di una istanza di «{0}» al tipo «{1}».";
    t[970] = "The column name {0} was not found in this ResultSet.";
    t[971] = "Colonna denominata «{0}» non è presente in questo «ResultSet».";
    t[976] = "Expected an EOF from server, got: {0}";
    t[977] = "Ricevuto dal server «{0}» mentre era atteso un EOF";
    t[978] = "Missing expected error response to copy cancel request";
    t[979] = "La richiesta di cancellazione «copy» non ha ritornato nessun messaggio di errore";
    t[990] = "Transaction isolation level {0} not supported.";
    t[991] = "Il livello di isolamento delle transazioni «{0}» non è supportato.";
    t[992] = "No value specified for parameter {0}.";
    t[993] = "Nessun valore specificato come parametro {0}.";
    t[994] = "A connection could not be made using the requested protocol {0}.";
    t[995] = "Non è stato possibile attivare la connessione utilizzando il protocollo richiesto {0}.";
    t[1002] = "Connection attempt timed out.";
    t[1003] = "Il tentativo di connessione è scaduto.";
    t[1004] = "Conversion of interval failed";
    t[1005] = "Fallita la conversione di un «interval».";
    t[1006] = "Currently positioned after the end of the ResultSet.  You cannot call deleteRow() here.";
    t[1007] = "La posizione attuale è successiva alla fine del ResultSet. Non è possibile invocare «deleteRow()» qui.";
    t[1010] = "Invalid character data was found.  This is most likely caused by stored data containing characters that are invalid for the character set the database was created in.  The most common example of this is storing 8bit data in a SQL_ASCII database.";
    t[1011] = "Sono stati trovati caratteri non validi tra i dati. Molto probabilmente sono stati memorizzati dei caratteri che non sono validi per la codifica dei caratteri impostata alla creazione del database. Il caso più diffuso è quello nel quale si memorizzano caratteri a 8bit in un database con codifica SQL_ASCII.";
    t[1012] = "The hostname {0} could not be verified.";
    t[1013] = "L''hostname {0} non può essere verificato.";
    t[1014] = "The parameter index is out of range: {0}, number of parameters: {1}.";
    t[1015] = "Il parametro indice è fuori intervallo: {0}, numero di elementi: {1}.";
    t[1018] = "Can''t use executeWithFlags(int) on a Statement.";
    t[1019] = "Non è possibile usare «executeWithFlags(int)» su di una istruzione.";
    t[1020] = "Unsupported Types value: {0}";
    t[1021] = "Valore di tipo «{0}» non supportato.";
    t[1032] = "Unknown Response Type {0}.";
    t[1033] = "Risposta di tipo sconosciuto {0}.";
    table = t;
  }
  public java.lang.Object handleGetObject (java.lang.String msgid) throws java.util.MissingResourceException {
    int hash_val = msgid.hashCode() & 0x7fffffff;
    int idx = (hash_val % 517) << 1;
    {
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
    int incr = ((hash_val % 515) + 1) << 1;
    for (;;) {
      idx += incr;
      if (idx >= 1034)
        idx -= 1034;
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
  }
  public java.util.Enumeration getKeys () {
    return
      new java.util.Enumeration() {
        private int idx = 0;
        { while (idx < 1034 && table[idx] == null) idx += 2; }
        public boolean hasMoreElements () {
          return (idx < 1034);
        }
        public java.lang.Object nextElement () {
          java.lang.Object key = table[idx];
          do idx += 2; while (idx < 1034 && table[idx] == null);
          return key;
        }
      };
  }
  public java.util.ResourceBundle getParent () {
    return parent;
  }
}
