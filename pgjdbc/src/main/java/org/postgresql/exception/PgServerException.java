/*
 * Copyright (c) 2020, PostgreSQL Global Development Group
 * See the LICENSE file in the project root for more information.
 */

package org.postgresql.exception;

import static org.postgresql.util.GT.tr;

import org.checkerframework.checker.nullness.qual.NonNull;
import org.checkerframework.checker.nullness.qual.Nullable;

import java.sql.SQLException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * This exception expose additional information send by the PostgreSQL server with the fields that
 * can appear in {@code ErrorResponse} and {@code NoticeResponse} messages.
 *
 * <p>This is included in the chain of exceptions throw by the driver and can be obtained as below:
 *
 * <pre>
 * {@code try (Statement stmt = con.createStatement()) {
 *    stmt.executeQuery("select foo()");
 *    fail("function foo() does not exist");
 * } catch (SQLSyntaxErrorException sqle) {
 *    if (sqle.getCause() instanceof PgServerException) {
 *        PgServerException pgex = (PgServerException) sqle.getCause();
 *        String message = pgex.getMessage();
 *        String sqlstatus = pgex.getSQLState();
 *        String formatedMessage = pgex.toString();
 *        String hint = pgex.getHint();
 *        int pos = pgex.getPosition();
 *    }
 * }}
 * </pre>
 *
 * @since 43.0.0
 */
public final class PgServerException extends SQLException {

  private static final long serialVersionUID = 9076822398423992194L;

  private static final Character SEVERITY = 'S';
  private static final Character SEVERITY_NOLOCALE = 'V';
  private static final Character MESSAGE = 'M';
  private static final Character DETAIL = 'D';
  private static final Character HINT = 'H';
  private static final Character POSITION = 'P';
  private static final Character WHERE = 'W';
  private static final Character FILE = 'F';
  private static final Character LINE = 'L';
  private static final Character ROUTINE = 'R';
  private static final Character SQLSTATE = 'C';
  private static final Character INTERNAL_POSITION = 'p';
  private static final Character INTERNAL_QUERY = 'q';
  private static final Character SCHEMA = 's';
  private static final Character TABLE = 't';
  private static final Character COLUMN = 'c';
  private static final Character DATATYPE = 'd';
  private static final Character CONSTRAINT = 'n';

  private final @NonNull Map<Character, String> messageParts;

  private PgServerException(Map<Character, String> serverResponse) {
    super(serverResponse.get(MESSAGE), serverResponse.get(SQLSTATE));
    this.messageParts = serverResponse;
  }

  /**
   * Read the server response fields returned by the PostgreSQL server.
   *
   * <p><b>API Note:</b> This method is for driver internal use only.
   *
   * @param serverResponse {@code ErrorResponse} or {@code NoticeResponse} message.
   * @return PgServerException with the Server Response additional fields.
   * @throws IllegalArgumentException if {@code serverResponse} is invalid or {@code null}.
   */
  public static PgServerException make(String serverResponse) {
    return new PgServerException(parseServerResponse(serverResponse));
  }

  /**
   * <b>Code:</b> the SQLSTATE code for the error. Always present.
   *
   * @return the sqlstate code field 'C'
   */
  @Override
  public @NonNull String getSQLState() {
    return messageParts.getOrDefault(SQLSTATE, "");
  }

  /**
   * <b>Message:</b> the primary human-readable error message. This should be accurate but terse
   * (typically one line). Always present.
   *
   * @return the message field 'M'
   */
  @Override
  public @NonNull String getMessage() {
    return messageParts.getOrDefault(MESSAGE, "");
  }

  /**
   * <b>Severity:</b> the field contents are ERROR, FATAL, or PANIC (in an error message), or
   * WARNING, NOTICE, DEBUG, INFO, or LOG (in a notice message), or a localized translation of one
   * of these. Always present.
   *
   * @return the severity field 'S'
   */
  public @NonNull String getSeverity() {
    return messageParts.getOrDefault(SEVERITY, "");
  }

  /**
   * <b>Severity:</b> the field contents are ERROR, FATAL, or PANIC (in an error message), or
   * WARNING, NOTICE, DEBUG, INFO, or LOG (in a notice message). This is identical to the S field
   * except that the contents are never localized. This is present only in messages generated by
   * PostgreSQL versions 9.6 and later.
   *
   * @return the severity not localized field 'V'
   */
  public @Nullable String getSeverityNoLocale() {
    return messageParts.get(SEVERITY_NOLOCALE);
  }

  /**
   * <b>Detail:</b> an optional secondary error message carrying more detail about the problem.
   * Might run to multiple lines.
   *
   * @return the detail field 'D'
   */
  public @Nullable String getDetail() {
    return messageParts.get(DETAIL);
  }

  /**
   * <b>Hint:</b> an optional suggestion what to do about the problem. This is intended to differ
   * from Detail in that it offers advice (potentially inappropriate) rather than hard facts. Might
   * run to multiple lines.
   *
   * @return the hint field 'H'
   */
  public @Nullable String getHint() {
    return messageParts.get(HINT);
  }

  /**
   * <b>Position:</b> the field value is a decimal ASCII integer, indicating an error cursor
   * position as an index into the original query string. The first character has index 1, and
   * positions are measured in characters not bytes.
   *
   * @return the position field 'P'
   */
  public int getPosition() {
    return getIntegerPart(POSITION);
  }

  /**
   * <b>Where:</b> an indication of the context in which the error occurred. Presently this includes
   * a call stack traceback of active procedural language functions and internally-generated
   * queries. The trace is one entry per line, most recent first.
   *
   * @return the where field 'W'
   */
  public @Nullable String getWhere() {
    return messageParts.get(WHERE);
  }

  /**
   * <b>Schema name:</b> if the error was associated with a specific database object, the name of
   * the schema containing that object, if any.
   *
   * @return the schema name field 's'
   */
  public @Nullable String getSchema() {
    return messageParts.get(SCHEMA);
  }

  /**
   * <b>Table name:</b> if the error was associated with a specific table, the name of the table.
   * (Refer to the schema name field for the name of the table's schema.)
   *
   * @return the table name field 't'
   */
  public @Nullable String getTable() {
    return messageParts.get(TABLE);
  }

  /**
   * <b>Column name:</b> if the error was associated with a specific table column, the name of the
   * column. (Refer to the schema and table name fields to identify the table.)
   *
   * @return the column name field 'c'
   */
  public @Nullable String getColumn() {
    return messageParts.get(COLUMN);
  }

  /**
   * <b>Data type name:</b> if the error was associated with a specific data type, the name of the
   * data type. (Refer to the schema name field for the name of the data type's schema.)
   *
   * @return the data type name field 'd'
   */
  public @Nullable String getDataType() {
    return messageParts.get(DATATYPE);
  }

  /**
   * <b>Constraint name:</b> if the error was associated with a specific constraint, the name of the
   * constraint. Refer to fields listed above for the associated table or domain. (For this purpose,
   * indexes are treated as constraints, even if they weren't created with constraint syntax.)
   *
   * @return the constraint name field 'n'
   */
  public @Nullable String getConstraint() {
    return messageParts.get(CONSTRAINT);
  }

  /**
   * <b>File:</b> the file name of the source-code location where the error was reported.
   *
   * @return the file field 'F'
   */
  public @Nullable String getFile() {
    return messageParts.get(FILE);
  }

  /**
   * <b>Line:</b> the line number of the source-code location where the error was reported.
   *
   * @return the line field 'L'
   */
  public int getLine() {
    return getIntegerPart(LINE);
  }

  /**
   * <b>Routine:</b> the name of the source-code routine reporting the error.
   *
   * @return the routine field 'R'
   */
  public @Nullable String getRoutine() {
    return messageParts.get(ROUTINE);
  }

  /**
   * <b>Internal query:</b> the text of a failed internally-generated command. This could be, for
   * example, a SQL query issued by a PL/pgSQL function.
   *
   * @return the internal query field 'q'
   */
  public @Nullable String getInternalQuery() {
    return messageParts.get(INTERNAL_QUERY);
  }

  /**
   * <b>Internal position:</b> this is defined the same as the P field, but it is used when the
   * cursor position refers to an internally generated command rather than the one submitted by the
   * client. The 'q' (INTERNAL_QUERY) field will always appear when this field appears.
   *
   * @return the internal position field 'p'
   */
  public int getInternalPosition() {
    return getIntegerPart(INTERNAL_POSITION);
  }

  private int getIntegerPart(Character c) {
    String msgInt = messageParts.get(c);
    return msgInt == null ? 0 : Integer.parseInt(msgInt);
  }

  /**
   * Builds a formated message of the error returned by the server.
   *
   * <p>The basic format is:
   *
   * <pre>
   * SEVERITY: MESSAGE
   * </pre>
   *
   * @return formated server error message.
   * @see #getFormattedMessage(boolean)
   */
  @Override
  public @NonNull String toString() {
    return getFormattedMessage(false);
  }

  /**
   * Builds a formated message of the error returned by the server.
   *
   * <p>If {@code allDetails} parameter is true, then the message includes all the information
   * returned in the server response.
   *
   * <p>The general format is:
   *
   * <pre>
   * SEVERITY: MESSAGE
   *  Detail: DETAIL
   *  Hint: HINT
   *  SQL state: SQLSTATE
   *  Character: POSITION
   *  Context: WHERE
   *  Schema name: SCHEMA
   *  Table name: TABLE
   *  Column name: COLUMN
   *  Data type name: DATATYPE
   *  Constraint name: CONSTRAINT
   *  Internal Query: INTERNAL_QUERY
   *  Internal Position: INTERNAL_POSITION
   *  Location: ROUTINE, FILE:LINE
   * </pre>
   *
   * @param allDetails include all details in message.
   * @return formatted message string.
   */
  public @NonNull String getFormattedMessage(boolean allDetails) {
    StringBuilder message = new StringBuilder(48);
    message.append(messageParts.get(SEVERITY)).append(": ").append(messageParts.get(MESSAGE));

    if (allDetails) {
      append(message, "Detail: {0}", messageParts.get(DETAIL));
      append(message, "Hint: {0}", messageParts.get(HINT));
      append(message, "SQL state: {0}", messageParts.get(SQLSTATE));
      append(message, "Character: {0}", messageParts.get(POSITION));
      append(message, "Context: {0}", messageParts.get(WHERE));
      append(message, "Schema name: {0}", messageParts.get(SCHEMA));
      append(message, "Table name: {0}", messageParts.get(TABLE));
      append(message, "Column name: {0}", messageParts.get(COLUMN));
      append(message, "Data type name: {0}", messageParts.get(DATATYPE));
      append(message, "Constraint name: {0}", messageParts.get(CONSTRAINT));
      append(message, "Internal Query: {0}", messageParts.get(INTERNAL_QUERY));
      append(message, "Internal Position: {0}", messageParts.get(INTERNAL_POSITION));
      String routine = messageParts.get(ROUTINE);
      String file = messageParts.get(FILE);
      String line = messageParts.get(LINE);
      if (routine != null && file != null && line != null) {
        message.append(System.lineSeparator()).append(" ")
            .append(tr("Location: {0}, {1}:{2}", routine, file, line));
      }
    }

    return message.toString();
  }

  private void append(@NonNull StringBuilder message, @NonNull String msgFormat,
      @Nullable String msgPart) {
    if (msgPart != null) {
      message.append(System.lineSeparator()).append(" ")
          .append(tr(msgFormat, msgPart));
    }
  }

  /**
   * Read and parses the server ErrorResponse or NoticeResponse message fields returned by the
   * PostgreSQL server.
   */
  private static @NonNull Map<@NonNull Character, @NonNull String> parseServerResponse(String serverResponse) {
    if (serverResponse == null) {
      throw new IllegalArgumentException(tr("Server Response cannot be null"));
    }
    char[] chars = serverResponse.toCharArray();
    int pos = 0;
    int length = chars.length;
    Map<Character, String> msgParts = new HashMap<>();
    while (pos < length) {
      char msgType = chars[pos];
      if (msgType != '\0') {
        pos++;
        int startString = pos;
        // order here is important position must be checked before accessing the array
        while (pos < length && chars[pos] != '\0') {
          pos++;
        }
        msgParts.put(msgType, new String(chars, startString, pos - startString));
      }
      pos++;
    }
    if (msgParts.isEmpty()) {
      throw new IllegalArgumentException(tr("Invalid ErrorResponse or NoticeResponse message"));
    }
    return Collections.unmodifiableMap(msgParts);
  }

}
